# 6장. Process 스케쥴링

  * [6-1 스케줄링의 주요 개념](#6-1-스케줄링의-주요-개념)

## 6-1 스케줄링의 주요 개념

  1. 스케줄링이란?  
      운영 체제에서의 스케줄링은 프로세서의 시간을 여러 작업이나 프로세스 사이에 분배하는 방법을 말한다.  
      이는 준비 큐에 있는 작업 풀에서 선택하여 CPU 자원을 할당하는 것을 포함한다.  
      스케줄링은 다중 프로그래밍 환경에서 여러 작업이 동시에 실행되는 것을 지원하며, 이는 CPU 리소스를 효과적으로 여러 작업이나 프로세스 사이에 공유하고 전체 시스템의 성능을 향상시키는데 기여한다.

      스케줄링은 또한 운영 체제의 다른 중요한 개념, 예를 들면 다중 작업, 병렬 처리, 동시성 등을 지원한다.  
      이는 CPU의 사용을 최적화하고 모든 작업이 그들의 요구사항에 따라 완료되도록 보장하는 데 도움이 된다.

      스케줄링은 CPU 스케줄러, 즉 단기 스케줄러에 의해 수행되는 의사 결정 과정으로 볼 수 있다.  
      이는 큐 내의 프로세스의 실행 순서를 결정한다.  
      이 의사 결정 과정은 대기 시간 최소화, 부하 균형, 공정성 보장과 같은 특정 파라미터를 최적화하도록 설계된 다양한 스케줄링 알고리즘에 근거한다.

  2. 선점 스케줄링과 비선점 스케줄링  
      운영 체제의 스케줄링 전략은 크게 선점 스케줄링과 비선점 스케줄링 두 가지 유형으로 나뉜다.  
      선점 스케줄링과 비선점 스케줄링 핵심 차이는 프로세스와 CPU 리소스를 다루는 방식에 있다.

      * 비선점 스케줄링  
          비선점 스케줄링에서는 CPU가 프로세스를 시작하면 완료되거나 이벤트(예: 입력/출력 작업)에 의해 차단될 때까지 실행된다.  
          프로세스가 자발적으로 CPU를 놓을 때까지 CPU를 프로세스로부터 가져올 수 없다.  
          이 스케줄링 방법은 간단하고 이해하기 쉽지만, 한 큰 프로세스가 CPU를 내놓을 때까지 모든 다른 프로세스가 기다리는 컨보이 효과와 같은 문제를 야기할 수 있다.

          일반적으로 사용되는 비선점 스케줄링 알고리즘에는 선입선출(FCFS)과 최단 작업 우선(SJN)이 있다.

      * 선점 스케줄링  
          선점 스케줄링은 운영 체제가 현재 CPU에서 실행 중인 프로세스를 중단하고 준비 상태로 되돌릴 수 있게 해주어, 다른 프로세스가 실행될 수 있게 한다.  
          이 방법은 각 사용자가 CPU의 공정한 점유를 얻어야 하는 시분할 시스템에서 유용한다.

          선점 스케줄링은 프로세스 우선 순위와 같은 문제를 처리하고, 높은 우선 순위의 작업이 낮은 우선 순위의 작업이 완료될 때까지 기다리지 않도록 할 수도 있다.  
          그러나 이것은 여러 프로세스가 공유 데이터에 접근할 때 발생하는 경쟁 조건과 같은 복잡한 문제를 야기할 수도 있다.

          일반적으로 사용되는 선점 스케줄링 알고리즘에는 라운드 로빈(RR), 우선 순위 스케줄링, 최단 남은 시간 우선(SRTF) 등이 있다.

          선점 스케줄링과 비선점 스케줄링 모두 장점과 단점이 있다.  
          둘 중 어느 것을 선택할지는 일반적으로 시스템의 특정 요구 사항과 제약 조건에 따라 달라진다.  
          일부 시스템은 두 가지를 모두 사용하여 각각의 이점과 단점을 균형잡을 수 있다.

  3. 컨텍스트 스위칭  
      컨텍스트 스위칭은 선점 스케줄링과 밀접하게 관련된 중요한 개념이다.  
      컨텍스트 스위칭은 현재 실행 중인 프로세스에서 다른 프로세스로 CPU 제어를 전환하는 프로세스이다.  
      이는 운영 체제의 핵심 부분으로, CPU를 효과적으로 여러 프로세스 사이에 공유하는 데 도움이 된다.

      컨텍스트 스위칭 중에 운영 체제는 현재 실행 중인 프로세스의 상태(컨텍스트)를 저장하고, 다음에 실행할 프로세스의 상태를 복구한다.  
      컨텍스트에는 프로세스의 PC(Program Counter), 레지스터 값, 스택 정보 등이 포함될 수 있다.

      컨텍스트 스위칭은 리소스를 효과적으로 활용하고 시스템의 응답 시간을 최적화하는 데 중요한 역할을 하지만, 과도한 컨텍스트 스위칭은 시스템의 전체 성능에 영향을 줄 수 있다.  
      이는 각 컨텍스트 스위칭이 오버헤드를 발생시키기 때문이다.  
      따라서, 컨텍스트 스위칭은 필요할 때만 수행되어야 하며, 이를 관리하는 것은 스케줄링 알고리즘의 중요한 부분이다.

      결론적으로, 프로세스 스케줄링은 운영 체제 설계의 필수적인 부분이다.  
      이를 통해 시스템은 CPU 리소스를 효과적으로 관리하고, 공정성과 최적화 사이의 균형을 찾을 수 있다.  
      선점 스케줄링과 비선점 스케줄링 사이의 선택은 특정 사용 사례와 시스템 제약 조건에 크게 의존한다.  
      이러한 개념을 이해함으로써, 사람들은 컴퓨터 시스템이 어떻게 주어진 시간에 여러 작업과 프로세스를 처리하는지 더 잘 이해할 수 있다.

  4. 스케줄링 정책  
      스케줄링 정책은 프로세스가 어떻게 선택되고 CPU 시간이 할당되는지를 규정하는 규칙과 알고리즘이다.  
      일반적으로 사용되는 몇 가지 스케줄링 정책을 살펴보자.

      1. 선입선출 (FCFS)  
          선입선출 스케줄링 정책은 프로세스가 도착한 순서대로 실행되는 가장 간단한 정책 중 하나이다.  
          CPU는 큐의 첫 번째 프로세스에 할당되고, 해당 프로세스는 완료되거나 I/O 작업에 의해 차단될 때까지 계속 실행된다.  
          FCFS는 프로세스가 도착한 순서대로 실행되므로 공정성을 보장하지만, 실행 시간이 긴 작업 뒤에 대기하는 짧은 작업의 응답 시간이 느려질 수 있다.

      2. 최단 작업 우선 (SJN)  
          최단 작업 우선 스케줄링 정책은 실행할 다음 프로세스를 가장 짧은 실행 시간을 갖는 프로세스로 선택한다.  
          이 정책은 평균 대기 시간을 최소화하고 알려진 작업 길이 집합에 대해 최적의 스케줄링을 제공하기 위해 사용된다.  
          그러나 이 정책은 미리 실행 시간을 알아야 하므로 많은 실시간 시나리오에서는 실현 가능하지 않을 수 있다.

      3. 라운드 로빈 (RR)  
          라운드 로빈 스케줄링은 각 프로세스에 고정된 시간 양자 또는 타임 슬라이스를 할당하는 선점 정책이다.  
          CPU는 순환적으로 각 프로세스에 할당되며, 프로세스가 타임 슬라이스 내에서 완료되지 않으면 큐의 뒤로 이동한다.  
          RR은 모든 프로세스가 공평하게 실행할 수 있는 공정성을 제공하지만, 컨텍스트 전환 오버헤드가 높아지고 CPU 활용이 비효율적일 수 있다.

      4. 우선순위 스케줄링  
          우선순위 스케줄링은 각 프로세스에 우선순위를 할당하고 CPU를 가장 높은 우선순위를 갖는 프로세스에 할당한다.  
          실시간 작업과 같은 높은 우선순위 프로세스가 낮은 우선순위 프로세스보다 먼저 실행되도록 한다.  
          우선순위 스케줄링은 실행 중에 우선순위를 변경할 수 있는 선점형 또는 비선점형일 수 있다.

      5. 다중 대기열 스케줄링  
          다중 대기열 스케줄링은 우선순위에 따라 프로세스를 여러 대기열로 구성합니다. 각 대기열은 RR 또는 FCFS와 같은 자체적인 스케줄링 정책을 가질 수 있습니다. 프로세스는 우선순위에 따라 특정 대기열에 처음에 배치되고, 그 후 해당 대기열 내에서 스케줄링됩니다. 이 정책은 다양한 우선순위와 특성을 가진 다양한 유형의 프로세스를 처리하는 유연성을 제공합니다.

      6. 다중 피드백 대기열 스케줄링  
          다중 피드백 대기열 스케줄링은 프로세스가 동작에 따라 대기열 간 이동할 수 있는 다중 대기열 스케줄링의 확장입니다. CPU 시간이 더 필요하거나 더 높은 우선순위를 요구하는 프로세스는 더 높은 우선순위 대기열로 이동하고, 자주 차단되거나 낮은 우선순위를 갖는 프로세스는 낮은 우선순위 대기열로 이동할 수 있습니다. 이 정책은 프로세스의 동적 특성에 적응하여 응답 시간과 자원 활용을 최적화합니다.

  5. 프로세스 스케줄링  
      리눅스 커널은 5개의 스케줄러를 지원하며, 프로세스가 이를 유연하게 사용하도록 스케줄러의 세부 동작을 샛체화 했다.  
      이를 스케줄러 클래스라고 부르며 종류는 아래와 같다.  

      1. Stop Scheduler  
          Stop Scheduler는 모든 프로세스를 일시 중지시켜 활성 작업의 실행을 중단하는 기본적인 스케줄러 클래스이다.  
          에너지 절약 모드나 시스템이 유휴 상태로 들어가야 하는 경우에 자주 사용된다.

      2. Deadline Scheduler  
          Deadline Scheduler는 시간에 민감한 작업을 위해 설계된 실시간 스케줄러 클래스이다.  
          작업의 긴급성에 따라 우선순위를 할당하여 작업이 지정된 Deadline을 준수하도록 보장한다.  
          Deadline이 더 이른 작업이 먼저 실행되어 시간에 민감한 작업이 제때 완료될 수 있도록 한다.

      3. RT Scheduler  
          RT Scheduler는 실시간 작업의 결정적이고 예측 가능한 실행을 보장하는 또 다른 실시간 스케줄링 클래스이다.  
          작업에 고정된 우선순위를 할당하고 우선순위 기반 선점을 사용하여 제때 처리를 보장한다.  
          RT Scheduler는 엄격한 타이밍 요구 사항을 충족해야 하는 시스템에서 일반적으로 사용된다.

      4. CFS Scheduler  
          CFS Scheduler는 많은 현대적인 운영 체제에서 사용되는 인기 있는 스케줄러 클래스이다.  
          CFS Scheduler는 공정성과 최적의 자원 할당을 목표로 한다.  
          CFS Scheduler는 "가상 실행 시간"이라는 개념을 활용하여 우선순위를 동적으로 할당한다.  
          실행 시간 기록을 기반으로 작업을 효율적으로 추적하고 스케줄링하기 위해 레드-블랙 트리를 유지한다.

      5. Idle Scheduler
          Idle Scheduler는 CPU가 유휴 상태인 경우에 작업을 실행하는 특수한 스케줄러 클래스이다.  
          시스템이 중요한 작업에 참여하지 않는 경우에 배경 작업, 유지 관리 활동 또는 다른 낮은 우선순위 작업을 수행하기 위해 유휴 CPU 사이클을 효율적으로 활용하는 데 사용된다.
