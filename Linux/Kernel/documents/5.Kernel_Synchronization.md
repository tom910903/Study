# 5장. 커널 동기화

  * [5-1 커널 동기화 주요 개념](#4-1-커널-타이머)
  * [5-2 커널 동기화 기법](#5-2-커널-동기화-기법)

운영 체제의 세계에서 커널 동기화는 시스템의 정확성, 신뢰성 및 성능을 보장하는 데 중요한 역할을 한다.  
커널은 여러 작업을 동시에 처리하며, 데이터 무결성을 유지하고 다른 프로세스 또는 스레드 간의 충돌을 방지하기 위해 적절한 동기화 메커니즘이 필수적이다.

## 5-1 커널 동기화 주요 개념

  * 임계 영역(Critical Section)  
      임계 영역은 공유 리소스나 변수에 접근하는 코드 부분을 가리킨다.  
      데이터의 손상이나 일관되지 않은 결과를 방지하기 위해 한 번에 하나의 스레드 또는 프로세스만 임계 영역을 실행할 수 있도록 보장하는 것이 중요하다.  
      여러 스레드가 동시에 공유 리소스에 접근하려고 할 때 레이스 컨디션(race condition)이 발생하여 예상치 못한 동작이 발생할 수 있다.

      커널 개발자는 락(lock), 세마포어(semaphore), 스핀락(spinlock)과 같은 동기화 기법을 사용하여 임계 영역을 보호한다.  
      이러한 메커니즘은 한 번에 하나의 스레드만 임계 영역에 진입할 수 있도록 하며, 다른 스레드는 리소스가 사용 가능해질 때까지 대기한다.  
      공유 리소스에 대한 접근을 제어함으로써 임계 영역을 안전하고 일관되게 실행할 수 있다.

  * 레이스 컨디션(Race Condition)  
      레이스 컨디션은 프로그램의 동작이 서로 다른 스레드나 프로세스의 상대적인 실행 시간에 의존할 때 발생한다.  
      다른 스레드나 프로세스 간의 병행 실행으로 인해 프로그램의 결과가 예측할 수 없게 된다.  
      레이스 컨디션은 데이터 손상, 데드락, 잘못된 프로그램 동작 등 다양한 문제를 야기할 수 있다.

      레이스 컨디션을 방지하기 위해 커널 개발자는 상호 배제(mutual exclusion), 동기화(synchronization), 연산의 순서화(ordering)를 강제하는 동기화 기법을 사용한다.  
      크리티컬 섹션을 적절하게 동기화함으로써 레이스 컨디션을 피하고 시스템의 원하는 동작을 달성할 수 있다.

## 5-2 커널 동기화 기법
  Linux 커널에서 동기화 기법은 데이터 무결성을 유지하고 동시에 실행되는 프로세스나 스레드 사이에서 공유 자원에 대한 접근을 조정하는 데 중요하다.  
  이러한 기법은 코드의 크리티컬 섹션을 제어하고 동기화된 방식으로 실행될 수 있도록 보장한다.  
  
  1. 스핀락  
      스핀락은 사용 가능한 락이 나타날 때까지 바쁜 대기(busy waiting)를 허용하는 동기화 원시(primitive)이다.  
      다른 개체에 의해 이미 확보된 스핀락을 획득하려는 스레드나 프로세스가 있을 경우, 해당 스핀락의 상태를 반복적으로 확인하며 바쁜 대기 루프에 진입한다.  
      스핀락은 락을 획득하는 예상 대기 시간이 짧을 때 적합하다.

      Linux 커널은 스핀락 획득과 해제를 위한 `spin_lock()`과 `spin_unlock()`과 같은 다양한 스핀락 API를 제공한다.  
      데드락과 같은 문제를 방지하기 위해 스핀락은 바쁜 대기를 포함하므로 다른 스레드의 실행에 지연을 유발할 수 있으므로 짧은 기간 동안만 보유해야 한다.

  2. 뮤텍스  
      뮤텍스(Mutex)는 상호 배제(mutual exclusion)를 준수하는 다른 동기화 메커니즘으로, 공유 자원에 대한 독점적인 접근을 제공한다.  
      스핀락과 달리 뮤텍스는 스레드나 프로세스가 락이 사용 가능해질 때까지 대기하는 동안 잠들 수 있다.  
      뮤텍스가 잠겨 있을 때 락을 획득하려는 다른 개체는 락이 해제될 때까지 대기 상태에 놓인다.

      Linux 커널은 `mutex_lock()`과 `mutex_unlock()`과 같은 뮤텍스 API를 제공하여 뮤텍스를 획득하고 해제할 수 있다.  
      뮤텍스는 락을 기다리는 예상 대기 시간이 상대적으로 긴 경우에 적합하며, 대기하는 동안 다른 스레드가 실행될 수 있도록 한다.

  3. 스핀락과 뮤텍스의 차이점  
      스핀락과 뮤텍스의 주요 차이점은 경합 상황을 처리하는 방식에 있다.  
      스핀락은 락이 사용 가능해질 때까지 스레드가 락의 상태를 반복적으로 확인하는 바쁜 대기(busy waiting)를 포함한다.  
      이 접근 방식은 락이 빠르게 해제될 것으로 예상되는 상황에서 효율적일 수 있다.  
      그러나 대기 시간이 길 경우 CPU 리소스를 소모하고 지연을 유발할 수 있다.

      반면, 뮤텍스는 락이 해제될 때까지 스레드가 잠들 수 있도록 하여 바쁜 대기를 피한다.  
      이 접근 방식은 예상 대기 시간이 긴 경우에 더 적합하다.  
      그러나 스레드의 잠들기와 깨어나는 과정은 약간의 오버헤드가 추가되며, 스핀락에 비해 성능에 영향을 미칠 수 있다.

      스핀락과 뮤텍스 중 어떤 것을 선택해야 하는지는 락 경합의 예상 정도, 대기 시간 예상값 및 사용 가능한 리소스와 같은 요소에 따라 다르다.  
      각 동기화 기법의 특성과 트레이드오프를 이해하는 것은 특정 시나리오에 적합한 메커니즘을 선택하기 위해 필수적이다.