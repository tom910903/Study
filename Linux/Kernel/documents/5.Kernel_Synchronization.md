# 5장. 커널 동기화

  * [5-1 커널 동기화 주요 개념](#4-1-커널-타이머)
  * [5-2 커널 동기화 기법](#5-2-커널-동기화-기법)
  * [5-3 스핀락](#5-3-스핀락)
  * [5-4 Mutex](#5-4-mutex)

운영 체제의 세계에서 커널 동기화는 시스템의 정확성, 신뢰성 및 성능을 보장하는 데 중요한 역할을 한다.  
커널은 여러 작업을 동시에 처리하며, 데이터 무결성을 유지하고 다른 프로세스 또는 스레드 간의 충돌을 방지하기 위해 적절한 동기화 메커니즘이 필수적이다.

## 5-1 커널 동기화 주요 개념

  * 임계 영역(Critical Section)  
      임계 영역은 공유 리소스나 변수에 접근하는 코드 부분을 가리킨다.  
      데이터의 손상이나 일관되지 않은 결과를 방지하기 위해 한 번에 하나의 스레드 또는 프로세스만 임계 영역을 실행할 수 있도록 보장하는 것이 중요하다.  
      여러 스레드가 동시에 공유 리소스에 접근하려고 할 때 레이스 컨디션(race condition)이 발생하여 예상치 못한 동작이 발생할 수 있다.

      커널 개발자는 락(lock), 세마포어(semaphore), 스핀락(spinlock)과 같은 동기화 기법을 사용하여 임계 영역을 보호한다.  
      이러한 메커니즘은 한 번에 하나의 스레드만 임계 영역에 진입할 수 있도록 하며, 다른 스레드는 리소스가 사용 가능해질 때까지 대기한다.  
      공유 리소스에 대한 접근을 제어함으로써 임계 영역을 안전하고 일관되게 실행할 수 있다.

  * 레이스 컨디션(Race Condition)  
      레이스 컨디션은 프로그램의 동작이 서로 다른 스레드나 프로세스의 상대적인 실행 시간에 의존할 때 발생한다.  
      다른 스레드나 프로세스 간의 병행 실행으로 인해 프로그램의 결과가 예측할 수 없게 된다.  
      레이스 컨디션은 데이터 손상, 데드락, 잘못된 프로그램 동작 등 다양한 문제를 야기할 수 있다.

      레이스 컨디션을 방지하기 위해 커널 개발자는 상호 배제(mutual exclusion), 동기화(synchronization), 연산의 순서화(ordering)를 강제하는 동기화 기법을 사용한다.  
      크리티컬 섹션을 적절하게 동기화함으로써 레이스 컨디션을 피하고 시스템의 원하는 동작을 달성할 수 있다.

## 5-2 커널 동기화 기법
  Linux 커널에서 동기화 기법은 데이터 무결성을 유지하고 동시에 실행되는 프로세스나 스레드 사이에서 공유 자원에 대한 접근을 조정하는 데 중요하다.  
  이러한 기법은 코드의 크리티컬 섹션을 제어하고 동기화된 방식으로 실행될 수 있도록 보장한다.  
  
  1. 스핀락  
      스핀락은 사용 가능한 락이 나타날 때까지 바쁜 대기(busy waiting)를 허용하는 동기화 원시(primitive)이다.  
      다른 개체에 의해 이미 확보된 스핀락을 획득하려는 스레드나 프로세스가 있을 경우, 해당 스핀락의 상태를 반복적으로 확인하며 바쁜 대기 루프에 진입한다.  
      스핀락은 락을 획득하는 예상 대기 시간이 짧을 때 적합하다.

      Linux 커널은 스핀락 획득과 해제를 위한 `spin_lock()`과 `spin_unlock()`과 같은 다양한 스핀락 API를 제공한다.  
      데드락과 같은 문제를 방지하기 위해 스핀락은 바쁜 대기를 포함하므로 다른 스레드의 실행에 지연을 유발할 수 있으므로 짧은 기간 동안만 보유해야 한다.

  2. 뮤텍스  
      뮤텍스(Mutex)는 상호 배제(mutual exclusion)를 준수하는 다른 동기화 메커니즘으로, 공유 자원에 대한 독점적인 접근을 제공한다.  
      스핀락과 달리 뮤텍스는 스레드나 프로세스가 락이 사용 가능해질 때까지 대기하는 동안 잠들 수 있다.  
      뮤텍스가 잠겨 있을 때 락을 획득하려는 다른 개체는 락이 해제될 때까지 대기 상태에 놓인다.

      Linux 커널은 `mutex_lock()`과 `mutex_unlock()`과 같은 뮤텍스 API를 제공하여 뮤텍스를 획득하고 해제할 수 있다.  
      뮤텍스는 락을 기다리는 예상 대기 시간이 상대적으로 긴 경우에 적합하며, 대기하는 동안 다른 스레드가 실행될 수 있도록 한다.

  3. 스핀락과 뮤텍스의 차이점  
      스핀락과 뮤텍스의 주요 차이점은 경합 상황을 처리하는 방식에 있다.  
      스핀락은 락이 사용 가능해질 때까지 스레드가 락의 상태를 반복적으로 확인하는 바쁜 대기(busy waiting)를 포함한다.  
      이 접근 방식은 락이 빠르게 해제될 것으로 예상되는 상황에서 효율적일 수 있다.  
      그러나 대기 시간이 길 경우 CPU 리소스를 소모하고 지연을 유발할 수 있다.

      반면, 뮤텍스는 락이 해제될 때까지 스레드가 잠들 수 있도록 하여 바쁜 대기를 피한다.  
      이 접근 방식은 예상 대기 시간이 긴 경우에 더 적합하다.  
      그러나 스레드의 잠들기와 깨어나는 과정은 약간의 오버헤드가 추가되며, 스핀락에 비해 성능에 영향을 미칠 수 있다.

      스핀락과 뮤텍스 중 어떤 것을 선택해야 하는지는 락 경합의 예상 정도, 대기 시간 예상값 및 사용 가능한 리소스와 같은 요소에 따라 다르다.  
      각 동기화 기법의 특성과 트레이드오프를 이해하는 것은 특정 시나리오에 적합한 메커니즘을 선택하기 위해 필수적이다.

## 5-3 스핀락
  스핀락은 리눅스 커널에서 사용되는 동기화 메커니즘으로, 여러 스레드나 CPU가 동시에 접근하는 것을 방지하기 위해 코드의 임계 영역(critical section)을 보호한다.  
  스핀락은 공유 자원에 대한 독점적인 접근을 제공하고 데이터 무결성을 보장한다.

  1. 스핀락의 특징  
      스핀락은 다음과 같은 주요 특징을 가지고 있다.  

      * 바쁜 대기 : 스핀락은 바쁜 대기(busy waiting)를 사용한다.  
      즉, 스레드가 스핀락을 획득하려고 시도했지만 이미 잠겨있는 경우, 스레드는 락이 사용 가능해질 때까지 반복적으로 확인하는 과정을 짧은 루프 안에서 계속한다.  
      이는 뮤텍스와는 달리 스레드가 락을 획득할 수 없을 때 블록되거나 잠들지 않는다.
    
      * 낮은 오버헤드: 스핀락은 뮤텍스에 비해 오버헤드가 낮다.  
      스핀락은 블로킹과 스레드를 깨우는 과정에서 발생하는 문맥 전환과 스케줄링을 피하기 때문이다.  
      이는 스핀락이 짧은 임계 영역을 보호하는 데 적합하게 만든다.
      
      * 선점 비활성화: 스핀락을 획득한 스레드는 일반적으로 선점을 비활성화하여 다른 스레드나 CPU가 임계 영역을 중단시키는 것을 방지한다.  
      이로써 임계 영역이 원자적으로 실행되고 간섭이 없이 실행된다.
      
      * 불공평성: 스핀락은 본질적으로 공정하지 않다.  
      즉, 락을 획득한 첫 번째 스레드가 락을 해제할 때까지 계속해서 스핀하면서 다른 스레드들이 락에 접근할 수 없게 될 수 있다.  
      그러나 스핀락은 짧은 임계 영역을 위해 설계되었으므로 공정하지 않음은 크게 문제되지 않는다.

  2. 스핀락 데이터 구조  
      리눅스 커널에서 스핀락은 `spinlock_t` 데이터 구조로 나타낸다.  
      ``` c
      typedef struct {
          raw_spinlock_t raw_lock;
      #ifdef CONFIG_GENERIC_LOCKBREAK
          unsigned int break_lock;
      #endif
      #ifdef CONFIG_DEBUG_LOCK_ALLOC
          struct lockdep_map dep_map;
      #endif
      } spinlock_t;
      ```
      raw_lock : 이 필드는 실제 스핀락을 나타낸다.  
      `raw_spinlock_t` 타입은 아키텍처에 특화된 저수준 스핀락 구현으로, 일반적으로 간단한 정수나 비트 필드로 구성된다.
      break_lock : 이 필드는 락 브레이킹(lock-breaking)에 사용된다.  
      락 브레이킹은 디버깅 기능으로, 만약 락이 지나치게 오랜 시간 동안 보유되었다면 다른 CPU에서 락을 해제할 수 있도록 한다.  
      이는 락이 오랜 시간 동안 잘못 보유되었을 경우에 사용되며, 잠재적인 데드락이나 다른 문제를 나타낸다.
      dep_map : 이 필드는 락 종속성 추적(lock dependency tracking)에 사용된다.  
      락 종속성 추적은 커널에서 잠재적인 락 종속성과 순서 문제를 탐지하고 진단하는 기능으로, 런타임 락 유효성 검사와 디버깅 목적을 위한 정보를 제공한다.

  3. 스핀락 예제  
      다음은 커널 코드에서 스핀락을 사용하는 예제이다.  
      ``` c
      #include <linux/spinlock.h>

      spinlock_t my_lock;

      void my_function(void) {
          // Acquire the spinlock
          spin_lock(&my_lock);

          // Critical section - protected by the spinlock
          // Perform operations on shared resources

          // Release the spinlock
          spin_unlock(&my_lock);
      }
      ```
      이 예제에서는 `spinlock_t` 데이터 구조를 사용하여 `my_lock`이라는 스핀락을 정의한다.  
      `my_function` 함수 내에서는 `spin_lock(&my_lock)`을 사용하여 스핀락을 획득하고, `spin_unlock(&my_lock)`을 사용하여 스핀락을 해제한다.  
      이 두 호출 사이의 코드의 임계 영역은 스핀락으로 보호되어 공유 자원에 대한 독점적인 액세스를 보장한다.

  스핀락은 잘못된 사용으로 인해 데드락이나 다른 동기화 문제가 발생할 수 있으므로 주의해서 사용해야 한다.  
  시스템 성능에 미치는 영향을 최소화하기 위해 스핀락을 가능한 짧은 시간 동안 보유하는 것이 중요한다.

## 5-4 Mutex
  뮤텍스(Mutex)는 상호 배제(mutual exclusion )를 위한 동기화 기법으로, 리눅스 커널에서 여러 스레드나 CPU에 의한 동시 접근으로부터 코드의 크리티컬 섹션을 보호하는 데 사용된다.  
  스핀락과 비교하여 상위 수준의 추상화를 제공하며, 장기간의 배타적 접근이 예상될 때 자주 사용된다.  

  1. 뮤텍스의 기본 개념  
      뮤텍스는 상호 배제를 제공하고 한 번에 한 스레드만 코드의 크리티컬 섹션에 접근할 수 있도록 보장하는 것이 목적이다.  

      * 잠금(Locking): 스레드는 뮤텍스를 잠글 수 있으며, 이는 보호된 리소스에 대한 배타적 접근을 의미한다.  
      다른 스레드가 이미 잠근 뮤텍스를 잠그려고 할 경우, 해당 스레드는 뮤텍스가 사용 가능해질 때까지 차단된다.
      
      * 잠금 해제(Unlocking): 크리티컬 섹션을 실행한 후, 스레드는 뮤텍스를 잠금 해제하여 뮤텍스를 기다리고 있는 다른 스레드가 뮤텍스를 획득하고 진행할 수 있도록 한다.
      
      * 소유권(Ownership): 일반적으로 뮤텍스는 현재 소유한 스레드와 관련된다.  
      뮤텍스를 획득한 스레드만이 뮤텍스를 해제할 수 있다.  
      다른 스레드가 뮤텍스를 해제하려고 시도하면 정의되지 않은 동작이 발생할 수 있다.
      
      * 차단(Blocking): 스레드가 이미 다른 스레드에 의해 잠겨진 뮤텍스를 잠그려고 할 경우, 해당 스레드는 차단되어 잠들게 되고 뮤텍스가 사용 가능해질 때까지 대기한다.  
      이는 바쁜 대기(busy waiting)를 피하고 CPU를 다른 작업에 활용할 수 있도록 한다.
      
      * 우선순위 역전(Priority Inversion): 뮤텍스는 우선순위 역전(priority inversion)에 취약할 수 있다.  
      이는 낮은 우선순위 스레드가 높은 우선순위 스레드가 기다리는 뮤텍스를 소유하는 경우에 발생할 수 있다.  
      이는 높은 우선순위 작업의 실행 지연을 초래할 수 있는 우선순위 역전 문제를 야기할 수 있다.  
      우선순위 상속(priority inheritance) 및 우선순위 천장 프로토콜(priority ceiling protocol)과 같은 다양한 기법을 사용하여 우선순위 역전 문제를 완화할 수 있다.

  2. 잠금과 잠금 해제 동작  
        뮤텍스의 잠금 및 잠금 해제 동작은 사용된 뮤텍스의 유형에 따라 다를 수 있다.  
        두 가지 일반적인 시나리오를 살펴보자.

      1. 일반 뮤텍스  
          일반 뮤텍스의 경우, 스레드가 이미 다른 스레드에 의해 잠겨진 뮤텍스를 잠그려고 할 경우, 해당 스레드는 차단되어 잠들게 되고 뮤텍스가 사용 가능해질 때까지 기다린다.  
          뮤텍스가 소유하고 있던 스레드가 뮤텍스를 해제하면, 대기하고 있던 스레드 중 하나가 깨어나 뮤텍스를 획득하게 된다.
      
      2. 재귀 뮤텍스  
          재귀 뮤텍스는 동일한 스레드가 여러 번 뮤텍스를 잠그고 차단되지 않고 잠글 수 있는 기능을 제공한다.  
          각 잠금 작업은 해당하는 수만큼의 잠금 해제 작업을 따라와야 뮤텍스를 완전히 해제할 수 있다.  
          재귀 뮤텍스는 이미 보유한 크리티컬 섹션에 다시 진입해야 하는 경우에 유용하다.
