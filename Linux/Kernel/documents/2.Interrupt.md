# 2장. Interrupt

  * [2-1 Interrupt 란?](#2-1-interrupt-란)
  * [2-2 Interrupt Context](#2-2-interrupt-context)
  * [2-3 Interrupt Handler](#2-3-interrupt-handler)
  * [2-4 인터럽트 핸들러의 호출 흐름](#2-4-인터럽트-핸들러의-호출-흐름)
  * [2-5 인터럽트 디스크립터](#2-5-인터럽트-디스크립터)
  * [2-6 인터럽트 비활성화](#2-6-인터럽트-비활성화)
  * [2-7 인터럽트 디버깅](#2-7-인터럽트-디버깅)
  * [2-8 인터럽트 후반부 기법이란?](#2-8-인터럽트-후반부-기법이란)
  * [2-9 IRQ Thread](#2-9-irq-thread)
  * [2-10 Soft IRQ](#2-10-soft-irq)
  * [2-11 Tasklet](#2-11-tasklet)

## 2-1 Interrupt 란?
  1. Interrupt 란?  
      컴퓨팅에서 인터럽트는 장치나 프로그램에서 프로세서의 주의를 끌기 위해 프로세서에 보내는 신호를 말한다.  
      인터럽트가 트리거되면 프로세서는 현재 실행 중인 명령어 실행을 중단하고 인터럽트 서비스 루틴(ISR)이라고도 하는 인터럽트 처리 루틴으로 전환하여 들어오는 신호를 처리한다.

      인터럽트는 키보드, 마우스, 디스크와 같은 입력/출력 장치나 시스템 호출, 트랩, 예외와 같은 소프트웨어 이벤트 등 다양한 소스에서 발생할 수 있다.  
      인터럽트는 프로세서가 입력 또는 출력 작업이 완료될 때까지 기다리는 시간을 줄여 리소스를 보다 효율적으로 사용할 수 있게 해주므로 최신 컴퓨팅 시스템에서 필수적인 부분이다.

      인터럽트는 하드웨어 인터럽트와 소프트웨어 인터럽트의 두 가지 주요 유형으로 분류된다.  
      하드웨어 인터럽트는 외부 장치 또는 주변 장치에 의해 트리거되며 비동기식으로 간주되므로 예측할 수 없는 시간에 발생한다.  
      반면에 소프트웨어 인터럽트는 프로그램이나 시스템 호출에 의해 생성되며 동기식이기 때문에 특정 시간에 발생한다.

      인터럽트가 발생하면 프로세서는 먼저 프로그램 카운터와 레지스터를 포함한 현재 상태를 메모리에 저장한다.  
      그런 다음 인터럽트 처리를 담당하는 인터럽트 서비스 루틴을 메모리에 로드하고 프로그램 카운터를 ISR의 시작 주소로 설정한다.  
      그런 다음 ISR이 실행되고 완료되면 프로세서는 이전 상태로 복원하고 인터럽트된 프로그램을 계속 실행힌다.

      인터럽트는 시스템 성능과 안정성에 중요한 역할을 한다.  
      인터럽트는 효율적인 멀티태스킹을 가능하게 하여 프로세서가 리소스 낭비 없이 여러 작업을 동시에 처리할 수 있게 해준다.  
      또한 인터럽트는 프로세서가 예기치 않은 이벤트나 오류가 발생할 때 이를 처리할 수 있도록 하여 시스템 충돌 및 중단을 방지하는 데 도움이 된다.  

  2. 인터럽트 처리 과정  
    인터럽트 처리 프로세스에는 여러 단계가 포함된다.  

      <center><img src="../images/2.interrupt/Interrupt_Handling_Process.png" width="50%" height="75%"></center>

      1. 인터럽트 발생  
        인터럽트 처리 프로세스의 첫 번째 단계는 인터럽트 발생이다.  
        인터럽트는 키보드, 마우스 또는 디스크 드라이브와 같은 하드웨어 장치 또는 장치 드라이버 또는 운영 체제 서비스와 같은 소프트웨어 프로그램에 의해 발생할 수 있다.
      2. 인터럽트 알림  
        인터럽트가 발생하면 하드웨어 장치 또는 프로그램이 프로세서에 신호를 보내 인터럽트를 알린다.  
        이 신호는 일반적으로 장치 또는 프로그램을 프로세서에 연결하는 전용 회선인 하드웨어 인터럽트 라인을 통해 전송된다.
      3. 인터럽트 승인  
        프로세서는 인터럽트 신호를 승인하여 장치 또는 프로그램에 요청을 수신했음을 알려야한다.  
        이는 인터럽트 라인을 통해 승인 신호를 다시 전송하여 수행된다.
      4. 인터럽트 처리  
        인터럽트가 승인되면 프로세서는 인터럽트의 원인을 파악하고 적절한 인터럽트 핸들러 루틴을 실행해야 한다.  
        이 루틴은 인터럽트 요청을 처리하도록 특별히 설계된 코드 조각이다.
      5. 인터럽트 서비스  
        인터럽트 핸들러 루틴은 인터럽트 요청을 처리하는 데 필요한 작업을 수행한다.  
        여기에는 장치에서 데이터 읽기, 장치에 데이터 쓰기 또는 인터럽트 처리에 필요한 기타 작업 수행이 포함될 수 있다.
      6. 인터럽트 완료  
        인터럽트가 처리되면 프로세서는 인터럽트 요청이 완료되었음을 나타내는 신호를 장치 또는 프로그램에 보낸다.  
        그러면 장치 또는 프로그램이 정상 작동을 재개할 수 있다.

      요약하면 인터럽트 처리 프로세스에는 인터럽트 발생, 알림, 승인, 처리, 서비스 및 완료를 포함한 여러 단계가 포함된다.  
      각 단계는 컴퓨터 시스템의 효율적인 작동에 매우 중요하며 시스템 충돌이나 성능 문제를 방지하기 위해 신중하게 관리해야 한다.

## 2-2 Interrupt Context  
  1. 인터럽트 컨텍스트란?  
      인터럽트가 발생하면 프로세서는 현재 실행을 중지하고 인터럽트 핸들러 루틴으로 제어권을 넘긴다.  
      인터럽트 핸들러 루틴은 인터럽트 컨텍스트라는 특수 실행 컨텍스트에서 실행된다.  
      인터럽트 컨텍스트는 다른 시스템 작업을 방해하지 않고 빠르고 효율적으로 작업을 수행해야 하므로 프로세서의 일반 실행 컨텍스트와 다르다.

      * 인터럽트 컨텍스트의 특징  
        1. 인터럽트를 처리하는 동안에만 존재하는 임시 컨텍스트
        2. 프로세서의 일반 실행 컨텍스트보다 높은 우선 순위로 실행
        3. 시스템 리소스에 대한 액세스가 제한됨
        4. 다른 시스템 작업을 방해하지 않도록 작업을 빠르고 효율적으로 완료해야 함
        5. 중단된 프로세스의 상태를 저장하고 복원할 수 있어야 함

  2. 인터럽트 컨텍스트가 중요한 이유  
      인터럽트 컨텍스트가 중요한 이유는 시스템이 다른 시스템 작업을 방해하지 않고 인터럽트를 빠르고 효율적으로 처리할 수 있기 때문이다.  
      인터럽트는 하드웨어 오류나 사용자 입력과 같이 즉각적인 주의가 필요한 이벤트를 처리하는 데 사용된다.  
      만약, 인터럽트 핸들러 루틴이 작업을 완료하는 데 시간이 너무 오래 걸린다면 다른 시스템 작업을 방해하고 시스템 불안정을 초래할 수 있다.

      인터럽트 컨텍스트는 인터럽트된 프로세스의 상태를 저장하고 복원하는 메커니즘을 제공하므로 인터럽트 컨텍스트도 중요하다.  
      인터럽트가 발생하면 프로세서는 인터럽트된 프로세스의 상태를 저장하고 인터럽트 핸들러 루틴에 제어권을 넘긴다.  
      그러면 인터럽트 처리기 루틴은 해당 상태를 저장하고 필요에 따라 인터럽트된 프로세스의 상태를 수정할 수 있다.  
      인터럽트 처리기 루틴이 완료되면 인터럽트된 프로세스의 상태를 복원하고 제어권을 다시 인터럽트된 프로세스로 전송한다.

## 2-3 Interrupt Handler  
  인터럽트 핸들러는 인터럽트가 감지될 때 실행되는 작은 코드 조각이다.  
  인터럽트 핸들러는 운영 체제의 중요한 부분이며 입출력 작업, 장치 드라이버 및 기타 저수준 시스템 기능을 처리하는 데 사용된다.

  1. 인터럽트 핸들러란?  
      인터럽트 핸들러는 인터럽트에 대한 응답으로 실행되는 함수이다.  
      인터럽트가 발생하면 프로세서는 현재 프로그램의 실행을 중지하고 인터럽트 핸들러에 제어권을 넘긴다.  
      인터럽트 핸들러는 인터럽트를 처리하고 인터럽트된 프로그램에 제어권을 다시 돌려주는 역할을 한다.

      인터럽트 핸들러는 다음과 같은 다양한 시스템 기능에 사용된다.  

      * 장치 드라이버: 인터럽트 핸들러는 하드 드라이브, 키보드, 네트워크 어댑터와 같은 장치에서 생성된 하드웨어 인터럽트를 처리하는 데 사용된다.  
      * 입력/출력 작업: 인터럽트 핸들러는 디스크 읽기 및 쓰기, 네트워크 트래픽 및 기타 데이터 전송과 같은 입력/출력 작업을 관리하는 데 사용된다.
      * 시스템 호출: 인터럽트 핸들러는 사용자 프로그램이 만든 시스템 호출을 처리하는 데 사용된다.

  2. 인터럽트 벡터란?  
      인터럽트 벡터는 인터럽트를 해당 인터럽트 핸들러에 매핑하는 데 사용되는 데이터 구조이다.  
      각 인터럽트에는 고유한 인터럽트 번호가 할당되며, 이 번호는 인터럽트 벡터 테이블의 색인을 생성하는 데 사용된다.  
      인터럽트 벡터 테이블에는 가능한 각 인터럽트에 대한 인터럽트 핸들러 루틴에 대한 포인터 목록이 포함되어 있다.

      인터럽트가 트리거되면 CPU는 인터럽트 벡터 테이블에서 해당 항목을 조회하여 해당 인터럽트에 대한 인터럽트 핸들러 루틴의 주소를 찾는다.  
      그런 다음 이 주소가 프로그램 카운터(PC) 레지스터에 로드되어 CPU가 인터럽트 핸들러 코드를 실행하기 시작한다.

      인터럽트 벡터는 시스템의 하드웨어 계층과 소프트웨어 계층 사이에 추상화 수준을 제공하는 데 사용된다.  
      이를 통해 운영 체제는 기본 하드웨어 플랫폼에 관계없이 일관된 방식으로 인터럽트를 처리할 수 있다.

      * 인터럽트 벡터 테이블  
        인터럽트 벡터 테이블은 운영 체제에서 인터럽트를 관리하는 데 사용되는 데이터 구조이다.  
        인터럽트 번호를 해당 인터럽트 핸들러에 매핑하는 테이블이다.  
        인터럽트 벡터 테이블은 일반적으로 메모리에 저장되며 시스템 시작 중에 운영 체제에 의해 초기화된다.

        인터럽트 벡터 테이블의 각 항목에는 해당 인터럽트 번호에 대한 인터럽트 처리기 루틴의 주소가 포함되어 있다.  
        인터럽트가 발생하면 CPU는 인터럽트 번호를 사용하여 인터럽트 벡터 테이블을 인덱싱하여 인터럽트 핸들러 루틴의 주소를 찾는다.

      * 인터럽트 벡터 테이블 관리  
        인터럽트 벡터 테이블은 일반적으로 운영 체제에서 관리한다.  
        운영 체제는 시스템 시작 시 테이블을 초기화하고 런타임 중에 필요에 따라 업데이트할 책임이 있다.

        일부 운영 체제에서는 사용자 수준 프로그램이 인터럽트 벡터 테이블의 항목을 수정하여 자체 인터럽트 핸들러를 설치할 수 있다.  
        그러나 이는 일반적으로 특정 인터럽트에 대해서만 허용되며 일반적으로 권한이 있는 사용자로 제한된다.

## 2-4 인터럽트 핸들러의 호출 흐름  
  인터럽트 서비스 루틴(ISR)이라고도 하는 인터럽트 핸들러는 하드웨어 인터럽트 서비스를 담당하는 운영 체제 커널의 중요한 부분이다.  
  하드웨어 장치에서 인터럽트가 발생하면 프로세서는 현재 작업을 일시 중단하고 인터럽트 핸들러로 제어권을 전송한다.
  
  1. 인터럽트 벡터 테이블  
      하드웨어 장치가 인터럽트를 생성하면 프로세서에 신호를 보내면 프로세서는 현재 프로그램의 실행을 중지하고 인터럽트 벡터 테이블로 알려진 특정 메모리 위치로 점프한다.  
      인터럽트 벡터 테이블은 각 장치에 대한 인터럽트 핸들러의 메모리 주소를 포함하는 포인터 테이블이다.

      프로세서는 장치에서 생성된 인터럽트 번호를 사용하여 인터럽트 벡터 테이블에 인덱싱하고 해당 인터럽트 처리기의 주소를 가져온다.  
      그런 다음 인터럽트 핸들러가 실행되어 인터럽트를 처리한다.

  2. 인터럽트 핸들러의 호출 흐름  
    인터럽트 핸들러의 호출 흐름은 진입, 실행, 종료의 세 단계로 나눌 수 있다.

      1. 진입 단계  
          인터럽트가 발생하면 프로세서는 인터럽트된 태스크의 현재 상태를 스택에 저장하고 인터럽트 핸들러에 대한 새 실행 컨텍스트를 설정한다.  
          그런 다음 프로세서는 인터럽트 벡터 테이블에서 가져온 인터럽트 핸들러의 메모리 주소로 점프한다.

          인터럽트 핸들러가 입력되면 인터럽트 처리를 위한 환경을 설정하기 위해 몇 가지 중요한 작업을 수행한다.  
          이러한 작업에는 재귀적 인터럽트 처리를 방지하기 위해 동일한 유형의 추가 인터럽트를 비활성화하고, CPU 컨텍스트를 저장하고, 인터럽트를 승인하는 작업이 포함된다.

      2. 실행 단계  
          인터럽트 핸들러가 인터럽트 처리를 위한 환경을 설정하면 실제 인터럽트 처리 코드를 실행한다.  
          이 코드는 인터럽트를 생성한 특정 장치에 따라 달라질 수 있다.

          이 단계에서 인터럽트 핸들러는 장치에서 데이터를 읽고 메모리에 저장하거나 장치에 필요한 다른 작업을 수행한다.  
          또한 인터럽트 핸들러는 인터럽트 컨트롤러에 인터럽트 종료(EOI) 신호를 전송하여 인터럽트 처리 프로세스가 끝났음을 알린다.

      3. 종료 단계  
          인터럽트 처리 코드가 실행된 후 인터럽트 핸들러는 필요한 정리 작업을 수행하고 진입 단계에서 저장된 CPU 컨텍스트를 복원한다.  
          이러한 작업에는 인터럽트를 다시 활성화하고 인터럽트된 작업의 실행을 재개하는 작업이 포함된다.

          인터럽트 처리기가 정리 작업을 완료하면 중단된 작업으로 제어권이 반환되고 시스템이 정상 작동을 재개한다.

  3. 인터럽트 핸들러 등록 과정  
      1. 인터럽트 핸들러 함수 정의  
        인터럽트 핸들러를 등록하는 첫 번째 단계는 인터럽트를 처리할 함수를 정의하는 것이다.  
        이 함수는 처리할 인터럽트 번호와 일치하는 올바른 서명을 가져야 한다.  
        Linux 커널에서 인터럽트 핸들러는 `irqreturn_t` 반환 유형으로 선언되며 인터럽트 번호와 데이터 구조에 대한 포인터라는 두 가지 인수를 받는다.
          * [(참고) irqreturn_t 구조체](#참고-irqreturn_t-구조체)

      2. 인터럽트 회선 할당  
        다음 단계는 인터럽트 라인을 할당하는 것이다.  
        인터럽트 줄은 특정 하드웨어 장치와 연관된 고유 식별자이다.  
        Linux에서 인터럽트 라인은 정수로 표시된다.  
        `request_irq()` 함수는 인터럽트 회선을 할당하는 데 사용된다.

      3. 인터럽트 핸들러 등록  
        인터럽트 라인이 할당되면 인터럽트 핸들러를 커널에 등록할 수 있다.  
        이 작업은 `request_irq()` 함수를 사용하여 수행된다.
          ``` c
          int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);
          ```
          irq: 처리할 인터럽트 회선 번호  
          handler: 인터럽트 핸들러 함수에 대한 함수 포인터  
          flags: 인터럽트의 동작을 제어하는 플래그
          name: 인터럽트를 요청하는 장치를 식별하는 문자열  
          dev: 인터럽트를 요청하는 디바이스에 대한 포인터

      4. 인터럽트 회선 활성화  
        마지막 단계는 인터럽트 라인을 활성화하는 것이다.  
        이 작업은 `enable_irq()` 함수를 사용하여 수행된다.  
        인터럽트 회선이 활성화되면 인터럽트 핸들러가 인터럽트를 수신하기 시작한다.
          ``` c
          void enable_irq(unsigned int irq);
          ```
          irq: 활성화할 인터럽트 번호

## 2-5 인터럽트 디스크립터  
  Linux 커널에서 인터럽트 디스크립터는 인터럽트를 관리하는 데 사용되는 데이터 구조체이다.
  
  1. 인터럽트 디스크립터 구조체  
      인터럽트 디스크립터는 특정 인터럽트에 대한 인터럽트 핸들러를 관리하는 데 사용되는 데이터 구조체이다.
      
      ``` c
      #include <irqdesc.h>
      
      struct irq_desc {
        irq_flow_handler_t handle_irq;
        struct irq_chip * chip;
        struct msi_desc * msi_desc;
        void * handler_data;
        void * chip_data;
        struct irqaction * action;
        unsigned int status;
        unsigned int depth;
        unsigned int wake_depth;
        unsigned int irq_count;
        unsigned int irqs_unhandled;
        unsigned long last_unhandled;
        spinlock_t lock;
      #ifdef CONFIG_SMP
        cpumask_t affinity;
        unsigned int cpu;
      #endif
      #if defined(CONFIG_GENERIC_PENDING_IRQ) || defined(CONFIG_IRQBALANCE)
        cpumask_t pending_mask;
      #endif
      #ifdef CONFIG_PROC_FS
        struct proc_dir_entry * dir;
      #endif
        const char * name;
      };  
      ```
      status : 인터럽트 라인의 상태
      * IRQ_DISABLED : 인터럽트 라인이 비활성화됨
      * IRQ_INPROGRESS : 인터럽트 처리기가 현재 실행 중  
      * IRQ_PENDING : 인터럽트가 발생했지만 아직 처리되지 않음
      * IRQ_NOREQUEST : 인터럽트가 요청되지 않았음

      action : 인터럽트 라인과 연관된 인터럽트 핸들러 함수를 정의하는 연결된 `irqaction` 구조체 리스트
      * [(참고) irqaction 구조체](#참고-irqaction-구조체)

      depth : 인터럽트 핸들러가 중첩된 횟수  
      irq_count : 인터럽트가 발생한 횟수  
      wake_depth : 인터럽트가 시스템을 깨운 횟수  
      irq : 인터럽트 번호  
      threads_running : 인터럽트 라인에서 실행 중인 스레드 수  
      threads_handled: 인터럽트 핸들러가 처리한 스레드 수  
      last_unhandled: 인터럽트 핸들러가 마지막으로 처리한 스레드

  2. 인터럽트 발생 횟수를 저장 방법  
      인터럽트 관리의 중요한 측면 중 하나는 인터럽트 발생 횟수를 추적하는 것이다.  
      이는 일반적으로 인터럽트가 발생할 때마다 카운터를 증가시키는 방식으로 수행된다.

      Linux에서 `irq_desc` 구조체에는 인터럽트 발생 횟수를 저장하는 카운트 필드가 포함되어 있다.  
      인터럽트가 발생할 때마다 카운트 필드가 증가하며, 커널은 각 인터럽트가 발생한 횟수를 추적할 수 있다.
      이를 통해 디버깅 및 성능 분석에 사용할 수 있다.  

      카운트 필드 외에도 `irqaction` 구조체에는 인터럽트 번호를 식별하는 irq 필드도 포함되어 있습니다. 이를 통해 커널은 각 `irqaction` 구조를 특정 인터럽트와 연관시킬 수 있습니다.

## 2-6 인터럽트 비활성화  
  인터럽트를 비활성화하면 명시적으로 다시 활성화할 때까지 프로세서가 새 인터럽트에 응답하지 못한다.  
  이는 들어오는 인터럽트에 의해 중단될 가능성 없이 코드의 중요한 부분이 원자 단위로 실행되도록 해야 하는 일부 상황에서 유용할 수 있다.

  1. 인터럽트를 비활성화 시점  
    인터럽트를 비활성화하면 시스템 성능에 상당한 영향을 미칠 수 있으므로 필요한 경우에만 신중하게 수행해야 한다는 점에 유의해야 한다.  
    일반적으로 인터럽트를 가능한 한 짧은 시간 동안 비활성화했다가 가능한 한 빨리 다시 활성화해야 한다.
      1. SoC에서 정의한 하드웨어 블록에 정확한 시퀀스를 줘야할 경우  
      2. 시스템이 유휴 상태에 진입하기 직전의 '시스템의 상태 정보' 값을 저장하는 동작  
      3. 각 디바이스 드라이버가 서스펜드 모드로 진입할 때 디바이스 드라이버에 데이터 시트에서 명시 대로 정확한 특정 시퀀스를 줘야 할 경우
      4. 예외가 발생해서 시스템 리셋을 시키기 전

## 2-7 인터럽트 디버깅  
  1. /proc/interrupts  
      `/proc/interrupts` 파일은 인터럽트 핸들러 목록과 각 인터럽트가 발생한 횟수를 제공한다.  
      이 정보는 문제를 일으키는 인터럽트 처리기를 식별하는 데 도움이 될 수 있으므로 인터럽트 관련 문제를 디버깅할 때 유용하다.  
      `/proc/interrupts` 파일의 내용을 보려면 다음 명령을 실행하면 된다.  

      ``` bash
      $ cat /proc/interrupts
      ```
      그러면 각 인터럽트, 인터럽트 발생 횟수, 관련 인터럽트 처리기가 나열된 테이블이 표시된다.
      ``` bash
      ~$ cat /proc/interrupts
           CPU0       CPU1       CPU2       CPU3
      11:   25850592    9062984   14661780   11677172     GICv3  27 Level     arch_timer
      13:    5088356          0          0          0     GICv3  34 Level     ahci[2140000.ahci]
      14:          0          0          0          0     GICv3  38 Level     virtio0
      17:          0          0          0          0     GICv3  35 Level     ehci_hcd:usb1
      18:          0          0          0          0     GICv3 117 Edge      GPIO Key POWEROFF
      20:        126     374157          0          0       MSI 49152 Edge      xhci_hcd
      21:          0      14772          0          0       MSI 81920 Edge      virtio1-config
      22:         36          0          0    7704173       MSI 81921 Edge      virtio1-input.0
      23:         54          0    4018205          0       MSI 81922 Edge      virtio1-output.0
      24:          0          0          0          0       MSI 163840 Edge      virtio2-config
      25:       3816          0          0   25839364       MSI 163841 Edge      virtio2-virtqueues
      27:        417          0          0          0       MSI 16384 Edge      snd_hda_intel:card0
      IPI0:   1531396    1483571    1385372    1468393       Rescheduling interrupts
      IPI1:   9811931   14079844   12404008   12314432       Function call interrupts
      IPI2:         0          0          0          0       CPU stop interrupts
      IPI3:         0          0          0          0       CPU stop (for crash dump) interrupts
      IPI4:         0          0          0          0       Timer broadcast interrupts
      IPI5:         0          0          0          0       IRQ work interrupts
      IPI6:         0          0          0          0       CPU wake-up interrupts
      Err:          0
      ```

  2. 인터럽트 이벤트 추적  
    ftrace는 Linux 커널에 포함된 강력한 추적 도구이다.  
    인터럽트 핸들러 함수의 실행을 추적하여 인터럽트를 디버깅하는 데 사용할 수 있다.  
    ftrace로 인터럽트 이벤트를 추적하려면 다음 단계를 수행하면 된다.  

      1. ftrace를 활성화  
          ``` bash
          $ echo 1 > /sys/kernel/debug/tracing/tracing_on
          ```
      2. 인터럽트 이벤트를 활성화  
          ``` bash
          $ echo irq_handler_entry > /sys/kernel/debug/tracing/set_event
          $ echo irq_handler_exit > /sys/kernel/debug/tracing/set_event
          ```
      3. ftrace 로그의 출력 확인  
          ``` bash
          $ cat /sys/kernel/debug/tracing/trace
          ```
    
## 2-8 인터럽트 후반부 기법이란?  
  인터럽트는 하드웨어 장치, 타이머 또는 소프트웨어 인터럽트 등 다양한 소스에서 발생할 수 있다.  
  인터럽트가 발생하면 시스템은 현재 프로세스의 실행을 중지하고 특정 인터럽트를 처리하도록 설계된 특수 함수인 인터럽트 핸들러로 이동한다.  
  그러나 인터럽트 핸들러 자체는 실행하는 데 상당한 시간이 걸릴 수 있으며, 이로 인해 나머지 시스템에 문제가 발생할 수 있다.  
  예를 들어 네트워크 카드가 수신되는 패킷마다 인터럽트를 생성하는 경우 인터럽트 핸들러는 이러한 인터럽트를 처리하는 데 대부분의 시간을 소비할 수 있으며, 이로 인해 다른 프로세스가 지연되거나 심지어 CPU 시간이 부족해질 수 있다.

  이 문제를 해결하기 위해 운영 체제에서는 인터럽트 하반부 처리라는 기술을 사용하는 경우가 많다.  
  인터럽트 하반부 처리는 주 인터럽트 처리기보다 낮은 우선 순위로 실행되는 지연된 인터럽트 처리기이다.  
  인터럽트 핸들러가 완료될 때까지 안전하게 지연될 수 있는 모든 처리를 수행하는 것이 이 처리기의 역할이다.

  1. 인터럽트 후반부 기법을 적용하는 이유  
      지연 인터럽트 처리라고도 하는 지연 인터럽트 기법은 커널 프로그래밍에서 인터럽트 처리를 나중으로 연기하여 시스템 성능과 안정성을 향상시키는 데 사용되는 기법이다. 

      지연 인터럽트 기법을 적용하는 이유를 살펴보기 전에 먼저 커널에서 인터럽트가 어떻게 작동하는지 이해해 보자.

      일반적인 커널 시스템에서 인터럽트는 들어오는 네트워크 패킷이나 마우스 클릭과 같이 시간에 민감한 이벤트를 처리하는 데 사용된다.  
      인터럽트가 발생하면 프로세서는 즉시 현재 작업을 일시 중단하고 인터럽트 핸들러 코드를 실행하기 시작한다.  
      핸들러가 작업을 완료하면 프로세서는 일시 중단된 작업을 다시 시작한다.

      그러나 인터럽트 처리에는 상당한 시간이 소요될 수 있으며, 그 동안 프로세서는 다른 작업을 실행할 수 없다.  
      이는 특히 인터럽트가 자주 발생하는 트래픽이 많은 시스템에서 성능 문제를 일으킬 수 있다.

      이 문제를 해결하기 위해 지연 인터럽트 기법이 사용된다.  
      커널 프로그래밍에 이 기법이 적용되는 몇 가지 이유는 다음과 같다.  

      1. 시스템 성능 개선  
        인터럽트 처리를 나중으로 연기함으로써 프로세서는 그 동안 다른 작업을 계속 실행할 수 있다.  
        따라서 인터럽트가 시스템 성능에 미치는 영향이 줄어들고 전반적인 시스템 응답성이 향상된다.
      
      2. 인터럽트 지연 시간 감소  
        인터럽트 지연 시간은 인터럽트가 처리되는 데 걸리는 시간이다.  
        인터럽트 처리를 나중으로 연기하면 시스템에서 인터럽트 지연 시간을 줄이고 실시간 성능을 개선할 수 있다.

      3. 간소화된 인터럽트 처리  
        인터럽트 처리는 특히 인터럽트 회선과 같은 공유 리소스를 처리할 때 복잡할 수 있다.  
        인터럽트 처리를 나중으로 연기함으로써 시스템은 인터럽트 처리를 간소화하고 경쟁 조건이나 기타 문제의 가능성을 줄일 수 있다.

      4. 보다 유연한 시스템 설계  
        인터럽트 처리를 늦추면 보다 유연한 시스템 설계가 가능하다.  
        예를 들어, 시스템에서 여러 인터럽트를 동시에 처리하거나 특정 인터럽트의 우선 순위를 다른 인터럽트보다 우선시할 수 있다.
        
  2. 인터럽트 콘텍스트에서 많은 일을 하면 발생하는 일  
      인터럽트는 인터럽트 컨텍스트와 프로세스 컨텍스트의 두 가지 컨텍스트에서 처리할 수 있다.

        * 인터럽트 컨텍스트는 인터럽트가 수신될 때 실행되는 커널 코드의 중요한 섹션이다.  
        이 컨텍스트에서 프로세서는 인터럽트 서비스에만 집중하며 다른 인터럽트나 프로세스 컨텍스트 코드에 의해 중단될 수 없다.  
        인터럽트와 연관된 인터럽트 핸들러 함수는 인터럽트 컨텍스트에서 실행된다.

        * 프로세스 컨텍스트는 정상적인 프로세스 관련 작업이 발생하는 커널의 정상적인 실행 환경이다.  
        프로세스 컨텍스트 코드는 다른 인터럽트 또는 프로세스 컨텍스트 코드에 의해 중단될 수 있다.

      인터럽트 컨텍스트에서 많은 작업이 수행되면 시스템이 응답하지 않거나 충돌이 발생할 수 있다.  
      이는 인터럽트 컨텍스트가 프로세스 컨텍스트보다 높은 우선순위로 실행되고 인터럽트 핸들러 기능이 완료될 때까지 다른 인터럽트 또는 프로세스 컨텍스트 코드가 차단될 수 있기 때문이다.

  3. Top Half / Bottom Half 란?  
      인터럽트가 발생하면, 시스템은 현재 실행 중인 프로그램을 중지하고 인터럽트 서비스 루틴 (ISR)으로 이동하여 이벤트를 처리한다.  
      ISR은 인터럽트를 처리하기 위해 필요한 작업을 수행하는데, 이는 데이터 구조 업데이트, I/O 작업 시작 또는 나중에 수행할 작업 스케줄링 등이 포함될 수 있다.

      ISR은 Top half와 Bottom half로 나뉜다.  
      Top half는 인터럽트가 발생한 시점에서 중단되며 인터럽트가 비활성화된 상태에서 실행된다.  
      주요 역할은 인터럽트를 처리하고 필요한 최소한의 레이턴시로 작업을 수행하는 것이다.  
      반면에 Bottom half는 인터럽트가 활성화된 상태에서 실행되며 비시간적 작업을 완료하는 것이 주요 역할이다.  
      이는 예를 들어, Top half에서 큐에 작업을 스케줄링하고, Bottom half에서 큐에서 작업을 가져와 처리하는 것이다.

      1. Top half  
        ISR의 Top half는 일반적으로 즉각적으로 완료되어야하는 빠르고 시간적으로 중요한 작업에 사용된다.  
        이러한 작업에는 레지스터와 컨텍스트 저장, 데이터 구조 업데이트, I/O 작업 시작 등이 포함된다.  
        ISR의 Top half는 인터럽트가 일어나는 동안 다른 인터럽트가 발생하지 않도록 인터럽트가 비활성화된 상태로 실행된다.  
        이렇게 함으로써, ISR은 다른 인터럽트로 인해 방해받지 않고 작업을 완료할 수 있다.

      2. Bottom half  
        ISR의 Top half가 완료되면, 시스템은 인터럽트를 활성화하고 정상적인 동작으로 돌아간다.  
        그런 다음 ISR의 Bottom half가 나중에 실행될 수 있도록 예약된다.  
        ISR의 Bottom half는 메모리 해제, 통계 업데이트, 나중에 수행될 작업 스케줄링과 같은 비시간적 작업을 완료하는 것이 주요 역할이다.

      ISR의 Bottom half는 일반적으로 지연 처리 프로시저 호출(DPC) 또는 태스크렛을 사용하여 구현된다.  
      이러한 메커니즘을 사용하면, Top half가 작업을 완료한 후에 Bottom half를 나중에 실행할 수 있다.  
      Bottom half는 인터럽트가 활성화된 별도의 컨텍스트에서 실행되며, 다른 인터럽트가 발생할 수 있도록 허용된다.

      요약하면, ISR의 Top half는 시간적으로 중요한 작업을 처리하는 반면, Bottom half는 비시간적인 작업을 완료하는 것이 주요 역할이다.  
      Top half와 Bottom half를 사용하면 시스템이 인터럽트를 효율적으로 처리할 수 있으며, 시간적으로 중요한 작업이 비시간적인 작업을 차단하지 않고 빠르게 완료되도록 보장한다.

  4. 인터럽트 후반부 처리 기법 종류  
      인터럽트 처리는 병목 현상이 발생할 수 있는 고성능 시스템에서 까다로운 작업이 될 수 있다.

      이 문제를 해결하기 위해 수년에 걸쳐 다양한 인터럽트 처리 기법이 개발되었다.  
      이러한 기술은 인터럽트 처리를 최적화하고 인터럽트 처리와 관련된 오버헤드를 줄일 수 있다.  

      1. 폴링 기반 인터럽트 처리  
        가장 기본적인 인터럽트 처리 기술은 폴링(polling)이다.  
        이 기술에서는 CPU가 계속해서 인터럽트 소스의 상태를 확인하여 인터럽트가 발생했는지 여부를 결정한다.  
        인터럽트가 발생하면 CPU는 인터럽트를 비활성화하고 현재 컨텍스트를 저장한 후 인터럽트를 처리한다.  
        폴링 기반 인터럽트 처리는 간단하고 직관적이지만, CPU 사이클에 대해 비효율적이고 낭비적일 수 있다.

      2. Bottom half 인터럽트 처리  
        이 기술에서는 CPU가 인터럽트가 발생하면 즉시 Top half를 실행하여 인터럽트를 처리한다.  
        Top half는 CPU 컨텍스트를 저장하고 인터럽트를 인식하는 등 시간적으로 중요한 작업을 수행한다.  
        Top half가 완료되면 Bottom half를 나중에 실행하도록 예약한다.  
        Bottom half는 프로세스를 깨우거나 지연된 작업을 수행하는 등 비시간적인 작업을 수행한다.  
        이 기술은 인터럽트 지연 시간을 줄이고 시스템 응답성을 향상시킬 수 있다.

      3. 태스크렛(Tasklets)  
        태스크렛은 지연 실행 모델을 사용하는 Bottom half 인터럽트 처리의 한 형태이다.  
        이 기술에서는 Top half가 나중에 실행할 태스크렛을 예약한다.  
        태스크렛은 가벼우며 인터럽트 컨텍스트에서 실행되므로, 처리 요구 사항이 낮거나 보통인 인터럽트를 처리하는 데 이상적이다.

      4. 소프트 인터럽트(Softirqs)  
        소프트 인터럽트는 지연 실행 모델을 사용하는 또 다른 하향식 인터럽트 처리 기술이다.  
        이 기술에서는 인터럽트 핸들러의 상위 부분이 소프트 인터럽트를 나중에 실행하도록 예약한다.  
        소프트 인터럽트는 태스크릿보다 더 무거운 가중치를 가지며 커널 스레드의 컨텍스트에서 실행되므로 처리 요구 사항이 높은 인터럽트를 처리하는 데 적합하다.

      5. 인터럽트 스레드(Interrupt Threads)  
        인터럽트 스레드는 인터럽트를 처리하기 위해 전용 커널 스레드를 사용하는 인터럽트 처리 기술이다.  
        이 기술에서는 인터럽트 핸들러의 상위 부분이 인터럽트 스레드를 깨우고 처리할 인터럽트 작업을 전달한다.  
        인터럽트 스레드는 자체 컨텍스트에서 인터럽트 핸들러를 실행하므로 시스템 성능과 확장성을 향상시킬 수 있다.

## 2-9 IRQ Thread
일부 경우에는 인터럽트 처리에 필요한 작업량이 인터럽트 핸들러가 처리하기에는 너무 많을 수 있다.  
이러한 경우 IRQ 스레드를 사용하여 인터럽트 핸들러에서 일부 작업을 분리할 수 있다.  
그럼, IRQ 스레드가 무엇이고 어떻게 작동하는지에 대해 알아보자.  

  1. IRQ 스레드란?  
      IRQ 스레드는 인터럽트 핸들러가 처리하기에는 처리 시간이 더 필요한 인터럽트를 처리하는 데 사용되는 커널 스레드이다.  
      인터럽트가 발생하면 인터럽트 핸들러는 기본 처리를 수행한 후 남은 처리를 처리하기 위해 IRQ 스레드를 예약한다.

      IRQ 스레드는 인터럽트 핸들러와 별도의 CPU 코어에서 실행되어 인터럽트 핸들러와 IRQ 스레드가 병렬로 실행될 수 있다.  
      이를 통해 인터럽트 처리에 소요되는 시간을 크게 줄여 시스템 성능을 향상시킬 수 있다.

  2. IRQ Thread 동작  
      인터럽트가 발생하면 인터럽트 핸들러가 실행된다.  
      인터럽트 핸들러가 처리하는 작업이 너무 많은 경우 인터럽트 핸들러는 나머지 처리를 위해 IRQ 스레드를 예약한다.

      IRQ 스레드는 인터럽트 핸들러와 별개의 CPU 코어에서 실행되므로 인터럽트 핸들러와 IRQ 스레드가 병렬로 실행될 수 있다.  
      인터럽트 핸들러는 일반적으로 인터럽트를 인식하고 인터럽트와 관련된 데이터를 가져오는 등 기본 처리를 수행한다.  
      그런 다음 IRQ 스레드가 더 많은 시간이 소요되는 처리를 수행한다.

      IRQ 스레드가 처리를 완료하면 일반적으로 인터럽트 핸들러에게 처리가 완료되었다는 알림을 보낸다.  
      인터럽트 핸들러는 필요한 최종 처리를 수행하고 인터럽트 처리 과정을 완료할 수 있다.

  3. IRQ 스레드 사용의 장점
      IRQ 스레드 사용은 다음과 같은 여러 가지 이점이 있다.  

      1. 성능 향상  
        IRQ 스레드는 인터럽트 처리 시간을 크게 줄여 시스템 성능을 향상시킨다.
      2. 지연 시간 감소  
        인터럽트 핸들러와 IRQ 스레드를 병렬로 실행함으로써 IRQ 스레드는 인터럽트 지연 시간을 줄여 하드웨어 장치를 더 빠르게 처리할 수 있다.
      3. 확장성  
        IRQ 스레드는 별도의 CPU 코어에서 인터럽트를 처리할 수 있으므로 멀티코어 시스템에서 확장성과 성능을 향상시킬 수 있다.

  4. IRQ 스레드 사용의 단점  
      IRQ 스레드를 사용하는 것에는 다음과 같은 단점도 있다.

      1. 복잡성 증가  
        IRQ 스레드는 인터럽트 처리 과정에 추가적인 복잡성을 추가하여 디버깅과 문제 해결을 더 어렵게 만들 수 있다.
      2. 오버헤드 증가  
        IRQ 스레드는 시스템에 추가 오버헤드를 추가하기 때문에 전반적인 성능을 저하시킬 수 있다.

  5. IRQ Thread 생성  
      다음은 IRQ 쓰레드를 생성하는 프로세스의 단계이다.  

      1. 커널 쓰레드 함수 정의  
        먼저, IRQ 쓰레드가 생성될 때 실행되는 커널 쓰레드 함수를 정의해야 한다.  
        이 함수는 장치에게 수신된 인터럽트 요청을 처리한다.  
          ``` c
          static irqreturn_t my_interrupt(int irq, void *dev_id);
          ```
          irq : 인터럽트를 트리거한 인터럽트 번호  
          dev_id :  매개변수는 인터럽트 요청 시 등록된 디바이스 데이터에 대한 포인터

      2. 인터럽트 요청  
        다음으로, 처리할 디바이스에 대해 인터럽트를 요청해야 한다.  
        이는 request_irq() 함수를 사용하여 수행된다. 
          ``` c 
          int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev);
          ```
          irq : 요청할 인터럽트 번호  
          handler : 1단계에서 정의한 인터럽트 핸들러 함수에 대한 포인터
          flags : 인터럽트 요청의 동작을 지정(공유 여부 등)  
          name : 커널 로그에서 인터럽트 요청을 식별하는 데 사용되는 문자열  
          dev : 인터럽트 핸들러 함수에 전달될 디바이스 데이터에 대한 포인터

      3. IRQ 스레드 생성  
        인터럽트가 요청되면 kthread_create() 함수를 사용하여 IRQ 스레드를 생성할 수 있다.  
          ``` c
          struct task_struct *kthread_create(int (*threadfn)(void *data), void *data, const char *namefmt, ...);
          ```
          threadfn : 1에서 정의한 커널 스레드 함수를 가리키는 포인터  
          data : 커널 스레드 함수에 전달해야 하는 데이터를 가리키는 포인터  
          namefmt : 커널 로그에서 IRQ 스레드를 식별하는 데 사용되는 문자열입

      4. IRQ 스레드를 깨우기  
        IRQ 스레드를 생성한 후, 인터럽트 요청을 처리할 수 있도록 깨워주어야 한다.  
        이를 위해 wake_up_process() 함수를 사용한다.  
          ``` c
          int wake_up_process(struct task_struct *tsk);
          ```
          tsk : 깨어나게 할 프로세스의 task_struct 구조체의 포인터

      5. 정리  
        IRQ 스레드가 더 이상 필요하지 않을 때, free_irq() 함수를 사용하여 인터럽트 요청을 해제하고, kthread_stop() 함수를 사용하여 IRQ 스레드를 종료해야 한다.
        free_irq() 함수는 request_irq()를 사용하여 이전에 등록된 인터럽트 요청 라인(IRQ)을 해제하는 데 사용된다.  
          ``` c
          void free_irq(unsigned int irq, void* dev_id);
          ```
          irq : 해제할 IRQ 번호
          dev_id : IRQ와 연관된 디바이스 ID

  6. IRQ 스레드의 예시  
    IRQ 스레드를 생성한 후에는, wait_event_interruptible() 또는 wait_event() 함수를 사용하여 인터럽트를 처리할 수 있다.  
    이러한 함수는 지정된 조건이 참이거나 스레드가 인터럽트될 때까지 스레드를 차단한다.  
    다음은 IRQ 스레드에 대한 예시이다.  

      ``` c
      #include <linux/kthread.h>

      static struct task_struct *irq_thread;

      static int irq_thread_func(void *data)
      {
          while (!kthread_should_stop()) {
            wait_event_interruptible(wait_queue, interrupt_occurred());
            // Handle the interrupt here
        }
        return 0;
      }

      static int __init my_module_init(void)
      {
          irq_thread = kthread_create(irq_thread_func, NULL, "irq_thread");
          if (IS_ERR(irq_thread)) {
              printk(KERN_ERR "Failed to create IRQ thread\n");
              return PTR_ERR(irq_thread);
          }
          wake_up_process(irq_thread);
          return 0;
      }

      static void __exit my_module_exit(void)
      {
          kthread_stop(irq_thread);
      }

      module_init(my_module_init);
      module_exit(my_module_exit);

      ```

      이 예제에서는 wait_event_interruptible() 함수를 사용하여 인터럽트를 기다린다.  
      wait_queue 변수는 인터럽트가 발생할 때 IRQ 스레드를 깨우는 대기열이다.  
      interrupt_occurred() 함수는 인터럽트가 발생할 때 true를 반환한다.

      wait_event_interruptible() 함수가 반환되면 IRQ 스레드는 스레드 컨텍스트에서 인터럽트를 처리할 수 있다.  
      IRQ 스레드는 필요한 처리를 수행한 다음 대기 상태로 돌아갈 수 있다.

## 2-10 Soft IRQ  
현대 컴퓨터 시스템에서 인터럽트 처리는 다양한 하드웨어 이벤트를 처리하는 중요한 메커니즘이다.  
인터럽트 처리는 처리과정에서 수행되어야 할 작업량에 따라 빠르거나 느릴 수 있다.  
경우에 따라 하드웨어 이벤트는 상당한 양의 처리를 필요로 하며, 따라서 전통적인 인터럽트 처리 방식만으로는 충분하지 않을 수 있다.  
이를 해결하기 위한 방법으로 Soft IRQ를 사용한다.  

  1. Soft IRQ란?  
      Soft IRQ (소프트웨어 인터럽트 요청)는 전통적인 인터럽트 핸들러보다 더 많은 처리 시간을 필요로 하는 이벤트를 처리하기 위해 Linux 커널에서 사용되는 메커니즘이다.  
      Soft IRQ는 일반 인터럽트와 유사하지만, 지연 실행 방식으로 처리되므로 현재 인터럽트 핸들러가 실행을 완료한 후 처리된다.  
      Soft IRQ는 일반 인터럽트로 처리할 수 없는 복잡한 이벤트를 처리할 수 있도록 한다.

  2. Soft IRQ 핸들러  
      Soft IRQ 핸들러는 일반 인터럽트 핸들러와 유사하며 C 함수로 구현된다.  
      Soft IRQ 핸들러는 커널 초기화 과정에서 등록되며, Soft IRQ 프레임워크에 의해 실행된다.  
      Soft IRQ 이벤트가 발생하면 커널에서 Soft IRQ 핸들러가 호출된다.  
      Soft IRQ 핸들러는 현재 인터럽트 핸들러의 실행이 완료된 후에 실행되므로 지연 실행된다.

  3. Soft IRQ의 종류  
      Linux 커널은 여러 종류의 Soft IRQ를 지원하며, 각 Soft IRQ는 특정 유형의 이벤트를 처리한다.  
      일반적인 Soft IRQ는 다음과 같다.  
      1. Tasklets  
        Tasklets는 지연 처리가 필요한 작고 빠른 이벤트를 처리하는 데 사용되는 Soft  IRQ이다.  
        Tasklets는 인터럽트 컨텍스트에서 실행되며 빠르게 실행될 수 있도록 설계되었다.
      2. Workqueues  
        Workqueues는 처리 시간이 긴 이벤트를 처리하는 데 사용되는 Soft IRQ입니다.  
        Workqueues는 프로세스 컨텍스트에서 실행되며 긴 처리 시간이 필요한 이벤트를 처리할 수 있도록 설계되었다.
      3. Timer  
        타이머 Soft IRQ는 지정된 시간 이후에 발생하는 이벤트를 처리하는 데 사용된다.  
        타이머 Soft IRQ는 프로세스 컨텍스트에서 실행된다.

  4. Soft IRQ Handler 실행  
      Soft IRQ 핸들러는 현재 인터럽트 핸들러의 실행이 완료된 후에 실행되는 것처럼, 지연된 방식으로 실행된다.  
      Soft IRQ 핸들러는 Soft IRQ 프레임워크에 의해 호출되며, 이를 통해 올바른 컨텍스트에서 실행된다.  
      Soft IRQ 핸들러는 하드웨어 이벤트, 다른 Soft IRQ 핸들러 또는 커널 스레드에 의해 호출될 수 있다.
  

  5. Soft IRQ Service  
      Soft IRQ 서비스는 Soft IRQ에 응답하여 실행되는 함수이다.  
      소프트웨어에 의해 트리거되는 일부 유형의 지연 작업을 처리하기 위해 설계된 Soft IRQ 서비스는 인터럽트 컨텍스트와 유사하지만 몇 가지 중요한 차이점이 있다.

      1. Soft IRQ service 동작  
          Soft IRQ 서비스가 트리거되면, 해당 서비스 함수는 Soft IRQ와 관련된 큐에 추가된다.  
          이 함수는 일반적으로 CPU가 유휴 상태에 있거나 비교적 중요하지 않은 시스템 활동 중에 실행된다.  

          Soft IRQ 서비스 함수는 인터럽트 컨텍스트와 유사한 특수한 컨텍스트에서 실행된다.  
          이 컨텍스트를 Soft IRQ 컨텍스트라고한다.  
          Soft IRQ 컨텍스트는 일반 프로세스 컨텍스트보다 우선 순위가 높지만 인터럽트 컨텍스트보다 우선 순위가 낮다.

          Soft IRQ 서비스는 소프트웨어에 의해 트리거되는 일부 유형의 지연된 작업을 처리하기위한 것으로 설계되었다.  
          Soft IRQ 서비스가 처리 할 수있는 지연 작업의 예는 다음과 같다.

            1. 네트워크 드라이버가 수신 한 네트워크 패킷 처리
            2. 장치 드라이버가 트리거 한 소프트웨어 인터럽트 처리
            3. 커널 스레드에서 실행 할 작업 예약

      6. Soft IRQ service 이점  
          Soft IRQ 서비스를 사용하는 주요 이점 중 하나는 중요한 시스템 활동에 방해를 일으키지 않으면서 일부 유예된 작업을 적시에 실행할 수 있도록한다는 것이다.  
          이는 유예된 작업을 처리해야 하는 볼륨이 많은 상황에서 시스템 성능과 안정성을 향상시킬수 있다.

          또한, Soft IRQ 서비스의 또 다른 이점은 사용하기 쉽고 최소한의 오버헤드로 구현할 수 있다.  
          이는 코드에서 유예된 작업을 처리해야 하는 개발자들에게 매우 유용한 옵션으로 작용할 수 있다.

      7. Soft IRQ service 요청  
          일반적으로, Soft IRQ 서비스는 인터럽트 컨텍스트에서 즉시 수행할 수 없는 작업이 필요할 때 요청해야 한다.  
          Soft IRQ 서비스로 수행할 수 있는 작업의 예로는 다음이 있다.
          
            1. 네트워크 처리  
              네트워크 패킷은 인터럽트 컨텍스트에서 수신되며, 체크섬 검증이나 패킷 분류와 같은 처리가 필요할 수 있다.  
              이러한 처리는 Soft IRQ 서비스를 사용하여 지연시키고 수행할 수 있다.
            2. 태스크릿 스케줄링  
              태스크릿은 Soft IRQ 컨텍스트에서 수행되는 작은 지연 인터럽트 핸들러이다.  
              인터럽트 컨텍스트에서 즉시 수행할 수 없는 처리를 수행하는 데 사용할 수 있다.  
            3. 타이머 처리  
              타이머는 나중에 실행할 작업을 예약하는 데 사용할 수 있다.  
              타이머 처리는 Soft IRQ 컨텍스트에서 수행될 수 있다.

      8. Soft IRQ 서비스 처리  
          Soft IRQ가 발생하면 해당 Soft IRQ 핸들러가 실행되어 보류 중인 작업을 처리한다.  
          Soft IRQ 핸들러는 데이터 구조를 업데이트하거나 대기 중인 프로세스를 깨우는 등 필요한 모든 작업을 수행할 수 있다.

          Soft IRQ 핸들러는 `open_softirq()` 함수를 사용하여 등록된다.  
          ``` c
          void open_softirq(int nr, void (*action)(struct softirq_action *))
          ```
          nr : 생성 중인 소프트 인터럽트의 번호  
          소프트 인터럽트 번호는 `include/linux/interrupt.h` 헤더 파일에서 정의  
          action : 실행되는 함수 포인터  
          `struct softirq_action` 구조체는 소프트 인터럽트 핸들러가 처리할 작업을 대기열에 추가하는 데 사용

          한번 Soft IRQ 핸들러가 등록되면 `raise_softirq()` 함수를 사용하여 이를 발생시킬 수 있다.  
          ``` c
          void raise_softirq(unsigned int nr);
          ```
          nr : 소프트 인터럽트 번호

      9. ksoftirqd 스레드  
          ksoftirqd 스레드는 리눅스 커널에서 소프트 인터럽트를 처리하는 커널 스레드이다.  
          이 스레드는 각 CPU에서 실행되며 해당 CPU에서 발생한 소프트 인터럽트를 처리한다.  
          소프트 인터럽트가 발생하면 해당 인터럽트를 생성한 CPU와 연결된 큐에 추가된다.  
          ksoftirqd 스레드는 주기적으로 해당 CPU의 소프트 인터럽트 큐를 확인하고 대기 중인 소프트 인터럽트를 처리한다.

          * ksoftirqd 스레드 동작  
              ksoftirqd 스레드는 부팅 프로세스 중에 시작되며 시스템이 실행 중인 동안 백그라운드에서 실행된다.  
              소프트IRQ가 발생하면 해당 인터럽트를 생성한 CPU와 관련된 소프트IRQ 큐에 추가된다.  
              ksoftirqd 스레드는 주기적으로 해당 CPU에 대한 소프트IRQ 큐를 확인하고 대기 중인 모든 소프트IRQ를 처리한다.

              ksoftirqd 스레드는 커널의 태스크 스케줄러를 사용하여 예약된다.  
              스레드가 유휴 상태 일 때는 슬립되어 태스크 스케줄러의 대기열에 추가된다.  
              소프트IRQ가 소프트IRQ 큐에 추가되면 ksoftirqd 스레드가 깨어나서 해당 인터럽트를 생성한 CPU에서 실행되도록 예약된다.
          
          * ksoftirqd 스레드의 역할  
              ksoftirqd 스레드는 소프트 인터럽트가 적시에 처리되도록 보장하여 Linux 커널의 중요한 구성 요소이다.  
              소프트 인터럽트는 네트워크 처리, 작업 스케줄링 및 메모리 관리를 포함하여 커널이 다양한 작업을 수행하는 데 사용된다.  
              ksoftirqd 스레드가 올바르게 실행되지 않으면 소프트 인터럽트가 효율적으로 처리되지 않아 시스템 성능이 저하될 수 있다.

## 2-11 Tasklet  
  Linux 커널 프로그래밍에서 태스크릿은 지연된 작업 스케줄링을 위한 메커니즘이다.  

  1. 태스크릿이란?  
      태스크릿은 작업의 지연 처리를 가능하게하는 커널 메커니즘입니다.  
      즉, 태스크릿은 어떤 이벤트에 응답하여 나중에 실행될 함수이다.  
      태스크릿은 소프트 IRQ 컨텍스트에서 실행되며, 이는 비선점적이고 다른 소프트 IRQ 작업과 동시에 실행될 수 있다는 것을 의미한다.

      소프트웨어 인터럽트인 `TASKLET_SOFTIRQ`를 발생시켜 태스크렛을 예약한다.  
      태스크렛이 예약되면, 그것은 소프트웨어 인터럽트와 관련된 큐에 추가된다.  
      커널은 큐에 추가된 순서대로 태스크렛을 실행한다.

      태스크렛이 예약되면, `TASKLET_SOFTIRQ`의 소프트웨어 인터럽트 핸들러가 실행될 때 가능한 빨리 실행된다.  
      이 핸들러는 연관된 큐에 있는 모든 태스크렛을 추가된 순서대로 실행하는 책임을 지고 있다.

  2. Tasklet 유형  
      Tasklet에는 두 가지 유형이 있다.
      
      1. Bottom-half Tasklet  
        Bottom-half tasklet은 인터럽트 컨텍스트에서 예약된다.  
        일반적으로 인터럽트에 대한 저지연 처리를 수행하는 데 사용된다.  
        이러한 tasklet은 예약되자마자 가능한 빨리 실행되어 인터럽트 처리의 지연 시간을 최소화한다.

      2. Workqueue Tasklet  
        Workqueue tasklet은 프로세스 컨텍스트에서 예약된다.  
        일반적으로 나중에 지연 처리할 수 있는 더 높은 지연 처리를 수행하는 데 사용된다.  
        Workqueue tasklet은 특정 CPU에서 실행하도록 예약할 수도 있고, 사용 가능한 모든 CPU에서 실행할 수도 있다.

  3. Tasklet 생성 및 관리  
      Tasklet은 `tasklet_init()` 함수를 사용하여 생성된다.  

      ``` c
      void tasklet_init(struct tasklet_struct *tasklet,
                  void (*func)(unsigned long), 
                  unsigned long data);
      ```
      tasklet : 초기화될 tasklet을 나타내는 tasklet_struct 구조체에 대한 포인터  
      func : tasklet이 예약될 때 실행될 함수의 함수 포인터  
      data : func 함수에 전달될 값

      Tasklet이 생성되면 `tasklet_schedule()` 함수를 사용하여 실행 대기열에 예약할 수 있다.  
      ``` c
      void tasklet_schedule(struct tasklet_struct *t);
      ```
      t : 스케줄링할 tasklet_struct 구조체
      
      Tasklet을 실행하지 않도록 하려면, `tasklet_disable()` 함수를 사용하여 비활성화할 수 있다.  
      tasklet이 비활성화되면, `tasklet_enable()` 함수를 사용하여 다시 활성화 될 때까지 실행되지 않습니다.
      ``` c
      void tasklet_disable(struct tasklet_struct *t);
      void tasklet_enable(struct tasklet_struct *t);
      ```
      t : 작업을 나타내는 tasklet_struct 구조체에 대한 포인터

      [(참고) irqaction 구조체](#참고-tasklet_struct-구조체)


### (참고) irqreturn_t 구조체
``` c
#include <linux/irqreturn.h>

typedef enum {
        IRQ_NONE        = (0 << 0),
        IRQ_HANDLED     = (1 << 0),
        IRQ_WAKE_THREAD = (1 << 1),
} irqreturn_t;
```
IRQ_NONE : 인터럽트 처리기가 인터럽트를 처리하지 않았으며 다음 인터럽트 처리기(있는 경우)로 전달되어야 함  
IRQ_HANDLED : 인터럽트 핸들러가 인터럽트를 성공적으로 처리했으며 추가 조치가 필요하지 않음  
IRQ_WAKE_THREAD : 인터럽트 핸들러가 인터럽트를 처리했지만 추가 처리를 커널 스레드로 연기했음  
(커널 스레드가 깨어나서 처리를 완료하기 위해 실행됨)

### (참고) irqaction 구조체
``` c
struct irqaction {
  irq_handler_t handler;
  void * dev_id;
  void __percpu * percpu_dev_id;
  struct irqaction * next;
  irq_handler_t thread_fn;
  struct task_struct * thread;
  struct irqaction * secondary;
  unsigned int irq;
  unsigned int flags;
  unsigned long thread_flags;
  unsigned long thread_mask;
  const char * name;
  struct proc_dir_entry * dir;
};  
```
handler : 인터럽트 핸들러 함수  
dev_id : 디바이스 식별을 위한 쿠키  
percpu_dev_id : 디바이스 식별을 위한 쿠키  
next : 공유 인터럽트를 위한 다음 irqaction 포인터  
thread_fn : 스레드 인터럽트를 위한 인터럽트 핸들러 함수  
thread : 스레드 인터럽트를 위한 스레드 포인터  
secondary : 보조 인터럽트에 대한 포인터 (강제 스레딩)  
irq : 인터럽트 번호  
flags : 플래그  
  * IRQ_Gc_INIT_MASK_CACHE : 마스크 레그를 읽어 mask_cache를 초기화합니다.
  * IRQ_G_C_INIT_NESTED_LOCK : 부모 irq에서 irq_set_wake를 호출해야 하는 irq 칩에 대해 irq의 잠금 클래스를 중첩으로 설정합니다. 일반적으로 GPIO 구현
  * IRQ_G_C_MASK_CACHE_PER_TYPE : 마스크 캐시는 칩 유형별 비공개입니다.
  * IRQ_GC_NO_MASK : IRQ_DATA->마스크 계산하지 않음
  * IRQ_GC_BE_IO : 빅 엔디안 레지스터 액세스 사용(기본값: LE)

thread_flags : 스레드 관련 플래그  
thread_mask : 스레드 활동을 추적하기 위한 비트마스크  
name : 장치의 이름  
dir : proc/irq/NN/name 엔트리에 대한 포인터

### (참고) tasklet_struct 구조체
``` c
#include <interrupt.h>

struct tasklet_struct
{
    struct tasklet_struct *next;
    unsigned long state;
    atomic_t count;
    void (*func)(unsigned long);
    unsigned long data;
};
```
next : 리스트에서 다음 태스크렛을 가리키는 포인터  
state : 태스크렛의 상태  
count : 태스크렛이 실행된 횟수  
func : 태스크렛이 스케줄링될 때 실행될 함수를 가리키는 포인터  
data : 태스크렛 함수에 전달될 인수