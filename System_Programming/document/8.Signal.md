 ## 8장. **시그널**

  * [8-1 시그널의 개념](#8-1-시그널의-개념)
  * [8-2 시그널 보내기](#8-2-시그널-보내기)
  * [8-3 시그널 기본 처리](#8-3-시그널-기본-처리)
  * [8-4 시그널 집합](#8-4-시그널-집합)
  * [8-5 sigaction() 함수의 활용](#8-5-sigaction-함수의-활용)
  * [8-6 알람 시그널](#8-6-알람-시그널)
  * [8-7 기타 시그널 처리 함수](#8-7-기타-시그널-처리-함수)

### 8-1 시그널의 개념  
시그널은 소프트웨어 인터럽트로 프로세스에 뭔가 발생했음을 알리는 간단한 메세지를 비동기적으로 보내는 것을 말한다.  
시그널은 예외적인 상황이 발생하는 경우나 프로새스에서 다른 프로세스로 시그널을 전달할 때 발생한다,  
보통 시그널로 전달되는 메세지는 미리 정의된 상수를 사용하며, 시그널을 받은 프로세스는 시그널에 따른 기본 동작을 수행하거나, 무시하거나, 시그널 처리를 위해 지정한 함수를 수행한다.

1. 시그널의 발생  
시그널은 소프트웨어 인터럽트이다.  
시그널은 비동기적으로 발생하며, 리눅스 운영체제가 프로세스에 전달한다.  
시그널은 아래와 같은 경우에 발생한다.  
    1. 0으로 나누기와 같이 프로그램에서 예외적인 상황이 일어난 경우  
    2. 프로세스가 kill() 함수와 같이 시그널을 보낼 수 있는 함수를 사용해 다른 프로세스에 시그널을 보내는 경우  
    3. 사용자가 ctrl + C 와 같은 인터럽트 키를 입력한 경우  

2. 시그널 처리 방법  
    1. 기본 동작 수행  
        각 시그널에는 기본 동작이 지정되어 있다. 대부분 시그널의 기본 동작은 프로세스를 종료하는 것이다.  
        이 외에 시그널을 무시하거나 프로세스 수행 일시 중지, 재시작 등을 기본 동작으로 수행한다.
    2. 시그널 무시  
        프로세스가 시그널을 무시하기로 지정하면 시스템은 프로세스에 시그널을 전달하지 않는다.
    3. 지정된 함수 호출  
        프로세스에서 시그널 처리를 위해 미리 함수를 지정해두고 시그널을 받으면 해당 함수를 호출해 처리한다.  
        시그널 처리를 위해 지정하는 함수를 *시그널 핸들러* 라고 하며, 시그널을 받으면 기존 작업을 중지한 후 시그널 핸들러를 호출하여 처리한다.  
        시그널 핸들러를 처리한 후에는 기존 작업을 계속 수행한다.
    4. 시그널 블록  
        프로세스는 특정 부분이 실행되는 동안 시그널이 발생하지 않도록 블록킹할 수 있다.  
        블로킹된 시그널은 큐에 쌓여 있다가 시그널 블록이 해제되면 전달된다.

4. 시그널의 종류

|시그널|번호|기본 처리|발생 요건|
|:--:|:--:|:--:|--|
|SIGHUP|1|종료|행업으로 터미널과 연결이 끊어졌을 때 발생|
|SIGINT|2|종료|인터럽트로 사용자가 Ctrl + C 를 입력했을 때 발생|
|SIGQUIT|3|코어 덤프|종료 신호로 사용가 Ctrl + \ 를 입력했을 때 발생|
|SIGILL|4|코어 덤프|잘못된 명령어 사용|
|SIGTRAP|5|코어 덤프|trace나 break point에서 트랩 발생|
|SIGABRT|6|코어 덤프|abort() 함수에 의해 발생|
|SIGIOT|6|코어 덤프|SIGABRT와 동일|
|SIGBUS|7|코어 덤프|버스 오류로 발생|
|SIGFPE|8|코어 덤프|산술 연산 오류로 발생|
|SIGKILL|9|종료|강제 종료로 발생|
|SIGUSR1|10|종료|사용자가 정의해 사용하는 시그널 1|
|SIGSEGV|11|코어 덤프|세그먼테이션 오률로 인해 발생|
|SIGUSR2|12|종료|사용자가 정의해 사용하는 시그널 2|
|SIGPIPE|13|종료|잘못된 파이프 처리로 인해 발생|
|SIGALRM|14|종료|alarm() 함수에 의해 발생|
|SIGTERM|15|종료|소프트웨어 종료로 발생|
|SIGTKFLT|16|종료|보조 프로세서의 스택 오류로 발생(리눅스는 지원 안함)|
|SIGCHLD|17|무시|자식 프로세스의 상태가 변경될 때 발생|
|SIGCONT|18|무시|중지된 프로세스를 재시작할 때 발생|
|SIGSTOP|19|중지|중지 시그널로 이 시그널을 받으면 SIGCONT 시그널을 받을 때까지 프로세스 수행 중단|
|SIGTSTP|20|중지|사용자가 Ctrl + Z로 중지시킬 떄 발생|
|SIGTTIN|21|중지|터미널 입력을 기다리기 위해 중지시킬 때 발생||
|SIGTTOU|22|중지|터미널 출력을 위해 중지시킬 때 발생|
|SIGURG|23|무시|소켓에 긴급한 상황이 생기면 발생|
|SIGXCPU|24|코어 덤프|CPU 시간 제한을 초과할 때 발생|
|SIGXFSZ|25|코어 덤프|파일 크기 제한을 초과할 때 발생|
|SIGVTALRM|26|종료|가상 타이머가 종료할 때 발생|
|SIGPROF|27|종료|프로파일 타이머가 종료할 때 발생|
|SIGWINCH|28|무시|윈도우의 크기가 변경될 때 발생|
|SIGIO|29|종료|비동기식 입출력 이벤트로 발생|
|SIGPOLL|SIGIO|종료|SIGIO와 동일|
|SIGPWR|30|무시|전윈이 중단되거나 재시작할 때 발생|
|SIGSYS|31|코어 덤프|잘못된 시스템 호출로 발생|
|SIGUNUSED|32|무시|향후 사용을 위해 예약된 번호|

### 8-2 시그널 보내기  
프로그램에 시그널을 보내기 위해 kill(), rasie(), abort() 함수를 사용한다.  
프로세스를 종료하기 위해서는 `kill` 명령을 사용할 수 도 있다.  
*SIGKILL* 시그널을 사용하여 프로세스를 강제 종료하려면 아래와 같이 kill 명령을 사용한다.  
`kill -9 PID`

* 시그널 보내기 (kill)
``` c
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
```
pid : 시그널을 받을 프로세스의 PID  
sig : PID로 지정한 프로세스에 보내는 시그널
return value : 성공하면 0, 실패하면 -1  

sig가 0이면 시그널은 보내지 않고, 오류를 확인한다.

|pid|설명|
|:--:|--|
|pid = 0|측별한 프로세스(스케줄러 등)를 제외하고 현재 프로세스가 속한 프로세스 그룹의 모든 프로세스에게 시그널을 보낸다.|
|pid > 0|pid로 지정한 프로세스에 시그널을 보낸다.|
|pid = -1|유효 사용자 ID가 root가 아니면 특별한 프로세스를 제외하고 실제 사용자 ID가 시그널을 보내는 프로세스와 유효 사용자 ID가 같은 모든 프로세스에게 시그널을 보낸다.|
|pid < -1|pid로 지정한 프로세스가 포함된 모든 그룹의 프로세스에게 시그널을 보낸다.|

* 시그널 보내기 (raise)
``` c
#include <signal.h>

int raise(int sig);
```
sig : PID로 지정한 프로세스에 보내는 시그널
return value : 성공하면 0, 실패하면 -1  

raise() 함수는 호출한 프로세스에 인자로 지정한 시그널을 보낸다.
만약 시그널 핸들러가 호출되면 시그널 핸들러의 수행이 끝날 때까지 raise() 함수는 return 하지 않는다.

* 시그널 보내기 (abort)
``` c
#include <stdlib.h>

void abort(void)
```
abort() 함수는 호출한 프로세스에 SIGABRT 시그널을 보낸다.

### 8-3 시그널 기본 처리
프로세스가 시그널을 받을 떄 수행하는 기본적인 처리는 프로세스의 종료이다.  
만약 프로세스를 종료하기 전에 수행해야할 작업이 남아있거나 특정 시그널은 종료하지 않으려면, 시그널을 받을때 수행할 함수를 지정하면 된다.

* 시그널 핸들러 지정(signal)  
``` c
#include <signal.h>

typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```
signum : 시그널 핸들러로 철이하려는 시그널(SIGKILL, SIGSTOP 제외)  
handler : 시그널 핸들러의 함수명(SIG_IGN : 시그널을 무시, SIG_DFL : 시그널의 기본 처리 방법을 수행)

* 시그널 핸들러 지정(sigset)  
*권장 하지 않음*  
``` c
#include <signal.h>

sighandler_t sigset(int sig, sighandler_t disp);
```
sig : 시그널 핸들러로 처리하려는 시그널
disp : 시그널 핸들러의 함수명

### 8-4 시그널 집합
시그널은 보통 개별적으로 처리된다. 하지만 POSIX 표준에서 시그널과 관련해 정의한 함수중 상당수는 복수의 시그널을 처리할 수 있게 한다.  
이렇게 복수의 시그널을 처리할 수 있게 하기위해 도입된 개념이 시그널 집합이다.

1. 시그널 집합의 개념  
시그널 집합은 시그널을 비트마스크로 표현한 것으로 시그널 하나가 비트 하나를 가리킨다.  
비트값이 1이면 시그널이 설정된 것이고, 0이면 설정되지 않은 것이다.

``` c
typedef struct {
    unsigned long __val[_NSIG_WORDS];
}sigset_t;
```

2. 시그널 집합 처리 함수  

* 시그널 집합 비우기  
시그널 집합의 모든 비트를 0으로 설정한다.
``` c
#include <signal.h>

int sigemptyset(sigset_t *set);
```
set : 비우려는 시그널 집합의 주소
return value: 성공하면 0, 실패하면 -1  

* 시그널 집합에 모든 시그널 설정  
시그널 집합의 모든 비트를 1로 설정한다.  
(시스템에서 정의한 모든 시그널을 포함하는 집합으로 만든다.)
``` c
#include <signal.h>

int sigfillset(sigset_t *set);
```
set : 비우려는 시그널 집합의 주소  
return value: 성공하면 0, 실패하면 -1  

* 시그널 집합에 시그널 설정 추가  
signum으로 지정한 시그널을 set으로 지정한 시그널 함수에 추가한다.
``` c
#include <signal.h>

int sigaddset(sigset_t *set, int signum);
```
set : 비우려는 시그널 집합의 주소  
signum : 시그널 집합에 추가할 시그널  
return value: 성공하면 0, 실패하면 -1  

### 8-5 sigaction() 함수의 활용

### 8-6 알람 시그널

### 8-7 기타 시그널 처리 함수